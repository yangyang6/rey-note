# 面试冲刺



## naver china

09:30 成都市高新区天府三街199号太平洋保险金融大厦A区. 11层 16层

java基础(多态、运算符优先级继承多态)和虚拟机，还有数据库索引和sql，分布式最终一致性，图的算法，多线程的锁，JUC，JVM底层实现，



总部在北京，大连、延吉也有分公司。成都这边是纯研发团队，主要负责 NAVER 服务，多种 Back-End 系统、云端平台服务开发业务的技术支持，以及全球化企业使用的合作服务 LINE Works 的全球 Delivery 开发中心业务。

要架构 B/S, C/S 模式都有，网络方面主要是以 TCP 为主，更上层的协议是以 HTTP, HTTPS, Websocket 为主。薪资待遇的话，没有定岗也不好定薪，我这边不方便给您一个确定的答复，多多理解~

###  

#### synchronized和lock的区别 

synchronized底层上看是JVM层面的锁，是Java关键字，通过monitor对象来完成。

Lock是API层面的锁，偏向于自主控制锁，粒度更细。





#### CountDownLatch（倒计时计算器）



#### 阻塞队列

BlockQueue







#### 信号量Semaphore

Semaphore是JDK提供的一个同步工具，它通过维护若干个许可证来控制线程对共享资源的访问。如果许可证剩余数量大于零时，线程则允许访问该共享资源；如果许可证剩余数量为零时，则拒绝线程访问该共享资源。Semaphore所维护的许可证数量就是允许访问共享资源的最大线程数量，所以，线程想要访问共享资源必须从Semaphore中获取到许可证







#### final finally finalized区别

final修饰变量，方法，类，修饰的类和方法不能被继承，修饰的变量不能被更改（俗称常量）

finally是异常处理类的一部分，它只能在try/catch语句块中，表示与对于的try语句块执行的情况下，finally所包含的语句块一定能被执行，final的用法比较特殊，会撤销之前的return语句，继续执行最后的final块中的代码

finalized是Object里面的方法，GC的时候会调用这个方法



#### 动态代理

代理模式侧重于控制访问，代理对象不会改变目标对象的职责和能力，它提供与目标对象相同的接口，但会增加相应的逻辑来控制访问目标对象。



* <Strong>jdk动态代理</strong>

  jdk动态代理实际上是运行时通过反射的方式来实现的，将代理的方法调用转到目标对象上，最终将目标对象生成的任何结果返回给调用方

  <strong>实现代理模式的流程：</strong>

  1.抽象出目标对象的接口

  2.实现接口InvocationHandler创建代理业务

  3.使用newProxyInstance创建代理对象

  4.业务处理



jdk动态代理它有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理的实例？ 答案就是CGlib

* <strong>cglib动态代理</strong>

  cglib是一个基于ASM字节码生成库，它允许我们在运行时对字节码进行修改和动态生成，CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类的方法的调用并顺势织入横切逻辑。







#### redis持久化

* RDB持久化

  RDB持久化是将某个时间点的Redis数据保存到一个RDB文件中，RDB持久化也叫做快照持久化

  Redis提供2个命令创建RDB文件，一个是SAVE，另一个是BGSAVE（一般用这个）

* AOF持久化

  AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库数据的





#### 分布式锁

为什么用分布式锁：

为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在分布式集群系统需要一种互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题

在很多场景，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁

* 基础数据库实现分布式锁

* 基于缓存（Redis等）实现分布式锁

  不太推荐，redis的锁用来做限流还是可以

* 基于ZK实现分布式锁





#### 

#### Spring的事务传播行为

Spring中有7种类型的事务传播行为，事务传播行为是Spring框架提供的一种事务管理方式

* Propagation.REQUIRED

  默认值，如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务

  

* Propagation.SUPPORTS

  如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行

  

* Propagation.MANDATORY

  如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常

* Propagation.REQUIRES_NEW

  重新创建一个新的事务，如果当前存在事务，延缓当前的事务

* Propagation.NOT_SUPPORTED

  以非事务的方式运行，如果当前存在事务，暂停当前的事务

  

* Propagation.NEVER

  以非事务的方式运行，如果当前存在事务，则抛出异常

  

* Propagation.NESTE

  如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务



对静态内部类.class调用toString方法



Top K问题等，



如何多个进程(不是线程)执行临界区代码，



#### 如何把数组中的重复元素去掉然后按升序排序

冒泡加trim



一致性哈希算法，，，线程池，，Aop等



### 算法

#### 统计连续子数组和等于指定值的次数

Map去实现



#### Top N/K问题



### JVM问题

#### 类加载机制

类的加载指将类的.class文件的二进制数据读入内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区中的数据结构（<strong style="color:red">这个看着有点绕呀</strong>）

![wps5F9E.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125941772-1913742708.png)

类加载器并不需要等到某个类被”首次主动使用“时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它

##### 类的生命周期

![wps257C.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125943209-1443333281.png)

* 加载

  加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

  1、通过一个类的全限定名来获取其定义的二进制字节流。

  2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

  3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

  加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而且在Java堆中创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

* 连接

  * <strong>验证</strong>

  这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

  * 准备

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配

  这个时候进行内存分配的仅包括类变量（static），而不包含实例变量，实例变量会在对象实例化随着对象一块分配到堆中

  如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量Value就会被初始化为ConstValue属性所指定的值

  * 解析

* 初始化

* 结束生命周期

  

##### JVM类加载机制

* 全盘负责

  当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入

* 父类委托

  先让父类加载器试图加载该类，只有在父类加载器无法加载该类时，才会尝试从自己的类路径中加载该类

* 缓存机制

  缓存机制会让所有加载的类都加入到缓存中去

  

##### 类的加载

Class.forName():将类的.class文件加载到JVM中之外，还会对类进行解释，执行类中的static块

ClassLoader.loadClass():只干一件事，就是将.class文件加载到JVM中，只有在newInstance的时候才会去执行static块



##### 双亲委派模型

一个类加载器收到加载请求的时候，首先会把请求委托给父加载器去完成，依次向上，因此所有类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类的时候，即无法完成该加载，子加载器才会尝试去加载该类



#### JVM内存结构

JVM内存结构主要有三大块：堆内存、方法区和栈，堆内存是JVM中最大的一块，由新生代与老年代组成，而年轻代内存又被分成三部分，Eden空间，From Survivor空间，To Survivor空间，默认情况年轻代是按照8：1：1分配的

方法区存储类信息、常量、静态变量等数据，是线程共享区域

栈又分为java虚拟机栈和本地方法栈主要用于方法的执行

![JUtH_20121024_RuntimeDataAreas_6_MemoryModel](https://images2015.cnblogs.com/blog/331425/201606/331425-20160623115840235-1252768148.png)



每个区域的作用：

* Java堆（Heap）

  Java堆是Java虚拟机所管理的内存最大的一块区域，几乎所有的对象实例都在这里分配内存，现在收集器基本都是采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等

  如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OOM异常

* 方法区（Method Area）

  方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

* 程序计数器（Program Counter Register）

  它是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器

  此内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域

* JVM栈（JVM Stacks）

  它是线程私有的，它的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型

* 本地方法栈（Native Method Stacks）

  本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到Native方法服务



#### 判断对象是否存活

##### 引用计数法

现在基本都不用了，容易出现循环引用的情况

##### 可达性分析算法

通过一系列的被称为”gc roots“的对象作为起始点，从这些节点开始向下搜索，搜索所走的路径称为引用链，当一个对象到”gc roots“没有任何引用链相连时，则证明此对象是不可达的（不可用的）



##### 两个相互引用的对象，没有其他线程对他们进行引用，是否会被GC

面试时经常被问到这个问题，对于GC roots来说，这两个对象依然是unreachable，还是会被回收







#### GC算法和垃圾回收器

算法：

##### 标记 - 清除

垃圾收集时首先标记需要回收的对象，标记后统一回收标记的对象，清除之后会产生大量不连续的内存碎片。

##### 标记 - 整理

标记整理在标记完成之后让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

##### 复制

##### 标记 - 压缩

##### Tri-color Marking 三色标记法

解决GC运行时程序长时间挂起的问题（可以异步执行）

##### 分代收集算法

垃圾回收器：

##### Serial收集器

​	串行收集器是最古老，最稳定，效率比较高的收集器。只使用一个线程去回收，新生代使用复制算法，老年代使用标记-压缩算法。垃圾收集的过程中会Stop the World

##### ParNew

​	Serial收集器的多线程版本，新生代并行，老年代串行

##### CMS

​	一种以获取最短回数-停顿时间为目标的收集器，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）

	* 初次标记  GCroot对象， STW
	* 并发标记  所有old对象
	* 重新标记  修正并发标记 STW
	* 并发清理  标记清理



##### G1

​	与CMS收集器相比G1收集器有以下特点：

1、空间整合

2、G1采用标记-压缩算法，不会产生内存空间碎片

3、可预测停顿

MixGC：

* 初次标记  GCRoot对象，Region(Root Region)     STW
* RootRegion 
* 并发标记    同CMS，只不过遍历范围缩小
* 重新标记    同CMS  只不过用SATB算法
* 复制清理    只选垃圾数较多的region



Rset和Cset





##### 以年轻代和老年代区分

| 年轻代                         | 老年代       |
| ------------------------------ | ------------ |
| Serial                         | Serial Old   |
| ParNew                         | CMS          |
| Parallel Scarege(关注吞吐量的) | Parallel Old |



### Mysql

#### Mysql的索引有哪些

* 数据结构角度

  1.B+树索引

  2.Hash索引

  3.FullText索引

  4.R-Tree

* 物理存储角度

  聚集索引

  非聚集索引

* 逻辑角度

  1.主键索引

  2.普通索引或单单列索引

  3.多列索引（复合索引）：最左前缀匹配

* 唯一索引或非唯一索引

* 空间索引



#### 什么是回表、索引覆盖

回表就是比如我们建立了一个索引(a,b)，但是要查的数据包括(a,b,c),这样查询的时候就需要进行回表操作

而如果我们查询的就是(a,b)这样查询就可以进行了，称为索引覆盖。 

<strong>需要说明的是覆盖索引必须要存储索引列的值，而Hash，空间索引和全文索引不存储列的值，所以mysql只能用B+ tree索引做索引覆盖</strong>





#### SQL基础

stu表

| id   | name |
| ---- | ---- |
| 1    | 张三 |
| 2    | 李四 |
| 3    | 王五 |

score表

| id   | s_id | score |
| ---- | ---- | ----- |
| 1    | 1    | 80    |
| 2    | 1    | 90    |
| 3    | 2    | 98    |
| 4    | 2    | 95    |

##### 查出优生的结果（每科成绩大于90分）

<code>select name from stu  as stu where not exists (select 1 from score as s where s.score <=90 and s.`s_id` = stu.id)
and exists (select 1 from score as s where s.`s_id` = stu.id)</code>



##### mysql 里面on和where的区别

* on条件是在生成临时表时的使用条件，它不管on中的条件是否为真，都会返回左边表中的记录
* where是生成临时表后再对临时表进行过滤，条件不为真的就全部过滤掉
* 多张表（table >= 3）表连接on比where的查询效率要高



##### 有一张员工表，查出哪些大于部门平均工资的结果

![image-20200814102951083](/Users/yangli/Library/Application Support/typora-user-images/image-20200814102951083.png)

<code>select em1.* from employee as em1 ,(select avg(em.salary) as salary,em.dept_id from employee as em group by dept_id) as em2 
where em1.`dept_id` = em2.`dept_id` and em1.`salary` > em2.`salary`</code>





##### 求出每个部门领工资最多的那个人

![image-20200814112049221](/Users/yangli/Library/Application Support/typora-user-images/image-20200814112049221.png)



##### MySql索引

在innodb里，索引B+ Tree的叶子节点存储了整行数据，也就是主键索引（聚集索引）

而索引B+ Tree叶子节点存储了主键的值是非主键索引（非聚集索引）

非聚集索引在查时候回通过主键

* 聚集索引：数据行的物理顺序与列值（一般是主键那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引（相当于新华字典里面的拼音目录）
* 非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引（相当于新华字典里面的偏旁部首） — 可以细分普通索引、唯一索引、全文索引、复合索引（遵循最左匹配原则，where条件里面没有最左列的一列或多列，索引就不会起作用）



















有两个编程题，一个是线程同步的，基本就是如何确保临界区，最多只有三个线程进入。







### 内存泄漏

在java中内存泄漏就是存在一些被分配的对象，

首先这些对象是可达的，即在有向图中，存在通路可以与其连接；

其次，这些对象是无用的，即程序以后不在使用这些对象





### 什么是线程死锁，如何解决

产生死锁的条件有四个：

* 互斥条件：所谓互斥就是进程在某一时间内独占资源
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
* 不剥夺条件：进程已获得资源，在未使用之前，不能强行剥夺
* 循环等待条件：若干进程之前行程头尾相连的循环等待资源关系





# 腾铭惠商集团

### rocketmq消息一致性

rocketmq最新版本之后支持事务消息保持数据的最终一致性

事务消息可以保证本地事务和发送消息之间的原子性

Half（Prepare） Message

Message Status Check





### rocketMq避免重复消费

保证幂等性：无论怎么调多少次，结果都是一样的

消息ID的唯一记录，消息消费后就删除掉 ?











### 你所知道的锁

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png)





### springboot启动流程

### hystrix，ribbon，feign调用时长







# 美团面试冲刺

### 单例模式

手写几种：

1.饿汉式

2.懒汉式

3.双重校验锁

4.枚举



##### String和Stringbuilder/StringBuffer

String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且大量浪费有限的内存空间。

StringBuilder/StringBuffer 在修改的时候不会产生新的未使用的对象

StringBuilder 线程不安全的

StringBuffer 线程安全的





排序算法会哪些，

jvm了解多少



##### 线程池的使用，线程池几个参数的意义

* corePoolSize

* maxPoolSize
* keepAliveTime
* allowCoreThreadTimeout
* queueCapacity

1.当线程数小于核心线程数时，创建线程

2.当线程数大于核心线程数时，且任务队列未满时，加入任务队列

3.当线程数大于核心线程数时，且任务队列已满

​		1.若线程数小于最大线程数，则创建线程

​		2.若线程数大于最大线程数，则抛出异常，拒绝任务



MQ的会哪些，怎么确实MQ消息是否消费完，阻塞队列的原理，

ConcurrentHashMap的原理以及1.7版本和1.8版本的不同。

3.现场二面主要问项目经验，在项目中担当什么角色，发挥了什么重要作用。



美团一面：

1.设计模型（单例模式）； 

2.数据结构，手撕链表，实现单向链表反转；

3.数据库是怎么搭建的；

4.数据库用的哪些实体 ；

##### 每个实体之间关系(外键，中间表)；

一对一

一对多

多对多





7.Redis的理解；

8.Redis和Mysql的区别；

9.Redis用什么命令解决同时拿出多条数据；

10.Maven+SVN （解决出现同步冲突）；

11.FreeMaker的理解；

12.项目中遇到的问题怎么解决的；

13.Nginx，zookeper等了解过吗？



美团面试了两次吧，都是需要手写代码，不过一般问题不会很难，就是类似于实现一个死锁，或者排序算法之类的。但是问的问题的话我感觉没怎么根据简历上的项目问，主要还是看面试官想问什么吧。两次面试问的题基本上都不一样。

面试官的问题：

问tomcat的类加载机制，一个tomcat中多个项目的话，项目间的隔离是如何实现的。

答主要还是双亲委派机制吧，但是tomcat的加载机制和一般的jvm的加载顺序是不一样的，当时不是很清楚，所以没有完全对。

面试的整个过程问的问题还是比较基础的，其中有一个环境让你当场手写代码，思想大概就是用动态规划求最长公共子串。





##### 最长公共子串

*答*用动态规划。



一面是基础面，主要方向是线程池，string、stringbuffer，stringbuilder的区别，数据库索引，hashmap原理，linux指令，性能排查；二面结合项目谈架构，谈亮点，string算法考察，写一个单例模式。



1：一面：手写堆排序，笔试一道题+数据库+计算机网络

2：二面：问项目





# 国信杰云

聊的还是比较有意思的

SQL聊的比较多，关于连接之类的







# 质数斯达克

1.多线程用过没，具体场景

2.线程池参数介绍

##### ConcurrentHashMap 红黑树是怎么扩容

染色，左旋或右旋？



4.讲下公平锁/非公平锁的实现

5.zk 选举机制，paxos算法介绍下

##### 布隆过滤器

##### Netty为什么快

##### CMS/ParNew/G1垃圾回收区别

##### myiasm/innodb 应用场景



##### mysql5.6 mysql5.7 事务隔离级别方面的提升

Mysql5.7通过避免为只读事务分配事务ID，不为只读事务分配回滚段，减少锁竞争等多种方式，优化了只读事务的开销，提高了数据库的整体性能



##### Mysql隔离级别：

![image-20200819135113914](/Users/yangli/Library/Application Support/typora-user-images/image-20200819135113914.png)



##### for update定义

for update是一种行级锁，又叫排它锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其他用户只能查询但不能更新被加锁的数据行。如果其他用户想更新该表的数据行，则也必须对该表施加行级锁。即使多个用户对一个表均使用了共享更新，但也允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。

https://www.cnblogs.com/banma/p/11797560.html

注意：

1、FOR UPDATE仅适用于innoDB，且必须在事务处理模块（BEGIN/COMMIT）中才能生效

2、要测试锁定的状况，可以利用Mysql的Command Mode（命令模式），开两个视窗来做测试

3、Myisam只支持表级锁，InnoDB支持行级锁，添加了（行级锁/表级锁）锁的数据不能被其它事务再锁定，也不被其它事务修改。是表级锁时，不管是否查询到记录，都会锁定表。





##### 你所知道的引用类型

* 软引用
* 强引用
* 弱引用
* 虚引用

##### CompletableFuture





# 中建电商

##### 计算机网络相关

##### spring相关面试题，具体的使用方法和应用场景

##### MQ相关面试题，具体的使用方法和应用场景

##### spring事务传递，源码如果实现的

##### 1-100 三个线程，交替输出，保证顺序

```java
/**
 * 1-100，3个线程交替输出
 * synchronized实现方式
 */
public class OutPutThreadTest1 implements Runnable {
    private static Object lock = new Object();
    private static int count = 0;
    int no;
    public OutPutThreadTest1(int no) {
        this.no = no;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (lock) {
                if (count > 100) {
                    break;
                }
                if (count % 3 == this.no) {
                    System.out.println(this.no + "--->" + count);
                    count++;
                } else {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                lock.notifyAll();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(new OutPutThreadTest1(0));
        Thread t2 = new Thread(new OutPutThreadTest1(1));
        Thread t3 = new Thread(new OutPutThreadTest1(2));
        t1.start();
        t2.start();
        t3.start();
        t1.join();
        t2.join();
        t3.join();
    }
}
```



### Linux和TCP等偏底层的问题

##### TCP与UDP区别

1.UDP不需要连接，远地的主机在收到UDP报文后也不需要给出任何建议，对应的协议有DNS、TFTP、DHCP、NFS、SNMP等；TCP是面向连接的服务，在传输数据之前必须先建立连接，数据传输完成后要释放连接，对应的应用层协议主要有SMTP、TELNET、HTTP、FTP等

2.TCP提供可靠的传输（有序、无差错、不丢失、不重复），UDP提供不可靠的传输

3.TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销

4.TCP提供拥塞控制和流量控制；UDP不提供拥塞控制和流量控制



##### 多线程如何同步【质数斯达克好像也遇到这个问题】

临界区、互斥区、事件、信号量四种方式





##### spring starter模式

一种可插拔的应用模式

##### spring profile 和 maven 的profile

















##### JVM内存模型

##### mysql，dubbo和其他一些组件要理解到底层实现和源码层面



##### 深拷贝和浅拷贝

* 浅拷贝：拷贝的是引用
* 深拷贝：新开辟内存空间，进行值拷贝

##### default关键字

##### session过期与持久化











# 美团

1.自我介绍

 2. 实现一个简单异步事件框架算法，comsum，producter

    异步事件直接用锁实现，生产者消费者并不适用于任何异步场景



##### 求查出大于部门平均工资的人的明细SQL

笛卡尔积去做查询

https://blog.csdn.net/modelsetget/article/details/81974103





SQL标准

* 1992

* 1999



##### 手写代码，将一个数字字符串，用模拟的方式转换成int数字。

利用ASCII码辅助计算

str.charAt(i) - '0'



##### 求二叉树最长子结构

https://www.cnblogs.com/yangtong/p/6687078.html



##### 简单介绍二叉查找树，红黑树，B树，B+树性质

二叉查找树也叫二叉搜索树

红黑树：

1.每个节点都是红色或黑色

2.树的根始终是黑色的

3.没有两个相邻的红色节点

4.从节点（包括根）到其任何后代NULL节点的每条路径都具有相同数量的黑色节点







​	6.手推红黑树查找，删除

​	7. B树，B+树在数据库存储中的作用(有关索引)

	8. 数据库索引的分类，优化方式(聚簇索引，非聚簇索引，覆盖，复合索引等等的概念)



##### MyISAM 和InnoDB 的区别，实现方式。 





##### 设计模式，解释了几个常用的 

观察者模式、代理模式 【认真搞通】



​	12.HTTP协议 

​	13.一个网站请求从客户端到服务器端的过程 

​	14.JVM，内存模型，GC，类加载器，反射等等的知识。 

​	15.Spring框架的启动流程

​	16.Sring框架IOC和AOP的实现原理，写了一个简易的IOC和一个AOP 

​	17.了解redis的特性，平时是否有使用，使用了哪些数据结构，使用redis做了什么功能等等。 

​	18.集合框架的知识，hashmap，ArrayList，LinkedList源码相关知识，基本整个介绍了一遍，与hastable，concurrenthashmap相互的关联和区别 

​	19.synchronized与lock的区别

​	20.java中的锁，偏向，轻，重，的转换

一、简答题

1.浏览器访问一个网址的时候都有哪些过程（还要了解DNS查找的过程）

2.tcp三次握手，四次分手

二、编程题

1.二分查找

2.树的中序遍历

三、智力题

给你一个5L和3L桶，水无限多，怎么到出4L

## 二面

面试官问我觉得一面面的怎么样，我。。。。然后就看我做的试卷，我竟然连二分查找都写错，面试官说不对，然后我改了改就好了，然后面试官就问还有什么可以优化的地方吗？我只说出来一个。。然后又是自我介绍，说项目，问项目，问基础。差不多也是40分钟。

## 三面

过了几天，收到3面邮，应该是部门boss，也是自我介绍，然后出了两个题。

1）一个n*n的矩阵，按副对角线打印

2）4个瓶盖换1瓶酒，要和150瓶酒，他自己最少多少瓶？然后问了职业规划。感觉有1个小时。





有些我记不清了，大概记得的就这些

一面：

  1.给了一道编程题，从方格中的某一点怎么去到另外的点，有多少种走法

  2.数据库联合索引，比如用的是A_B_C,给出几种场景，问在搜索的时候会什么时候会用到索引，讲讲一般怎么对数据库进行优化和explain的用法



 #####  Integer t = null; int m=t; System.out.println(t) 其实考的是拆箱和装箱，再编译阶段是把字节码加进去，真正进行拆装箱的对坐还是再运行上

```java
Integer t = null;
int m = t;             //执行到这里就报错
System.out.println(t);
```

局部变量表和操作数栈里面的操作，通过javap去反编译查看



##### error和Exception区别 列举几个常见的错误









二面：

 1.死怼虚拟机，新生代和老年代的区别究竟是什么？垃圾回收器的算法有哪些？垃圾回收期的名字有哪些？stop-the-world究竟干嘛啦

2.数据库的索引为什么用树，对数据库有没有什么了解

3.说说集合有哪几种？hashSet的底层是什么？它不安全再哪里？hashmap为什么不安全？（一定要把那2中情况说清楚，环出现了会有什么后果）？如果让你来做，怎么在不加锁的前提下保证它的安全？？

4.JMQ是怎么保证我一定会收到别人发的消息

5.nio和aio的区别，一定要知道的很清楚，所有的细节

6.new一个线程池的参数

7.2个同步shopId让我来做同步怎么同步

##### 1000000个数，找K个最大

堆排序

9.快速排序

10.spring涉及到的设计模式

三面：

1.了解分布式锁吗，知道怎么用吗

2.知道项目中用到的远程框架它是怎么报警的，比如它怎么能在web页面进行监控，数据怎么上去的，，worker的底层吗，zooker是个什么东西，elastic是个啥

3.平常怎么进行mysql的优化

4.还出了一个概率题，比较简单，我就不说了

5.string是在新生代还是老年代还是永久代，用的虚拟机是什么版本的

6.2个同步shopId让我来做同步怎么同步

7.ibatis和mybatis的不同

8.redis的2中持久化方式

9.除了jsf还了解什么远程框架，说说对比







# 神策数据

##### Redis和Mysql的一致性

* 采用延时双删策略

  1）先删除缓存

  2）再写数据库

  3）休眠500毫秒

  4）再次删除缓存

  当然缓存设置一定的超时时间

* 异步更新缓存（基于订阅binlog的同步机制）

  1）读Redis：热数据存Redis

  2）写Mysql：增删改都是操作Mysql

  3）更新Redis：Mysql数据操作binlog，来更新Redis【可以结合canel对binlog做监听，然后利用消息队列的方式更新Redis】

  



##### 服务超时

##### 服务链路很长

##### ThreadLocal

用到的业务场景：一个线程经常遇到横跨若干方法的调用，需要传递的对象，也就是上下文对象（Context），它是一种状态，经常就是用户身份，任务信息，就会存在过渡传参的问题，这时候就需要ThreadLocal



ThreadLocal里面用完之后要及时清理，因为ThreadLocal对象的强引用不清理，只要线程一直不死，ThreadLocalMap的key-value一直就会涨

##### ConcurrentHashMap







# 极米科技

##### feign原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191201125843452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70)

* 通过Spring IOC容器实例，装配代理实例，然后进行远程调用
* 执行InvokeHandler调用处理器的invoke(...)方法
* 执行MethodHandler调用处理器的invoke(...)方法
* 通过feign client客户端成员，完成远程URL请求执行和获取远程结果











### 最大子列和问题





# 百词斩

Linux命令查看端口号占用 netstat，修改文件为只读 mount命令

session和cookie,localStorage,sessionStorage，以及应用场景



| Cookie                   | LocalStorage               | SessionStorage               | Session                |
| ------------------------ | -------------------------- | ---------------------------- | ---------------------- |
| 跟着请求头每次提交都带上 | 不随请求头提交，可随时保存 | 不支持标签页，页面关闭即失效 |                        |
|                          |                            |                              | 适用一些敏感数据的记录 |

相同点：K-V 存储，同域名可用

不同点：前面三个都是存在客户端浏览器上面，Session是存储在服务器端的

设置cookie，设置了后会再后续的请求中带上

<code>document.cookie="kkk=vvv"</code>

localStorage 在HTML5中推荐的用法

<code>localStorage.setItem('kk','vv')</code>

​	

##### 进程与线程

进程是系统进行资源分配和调度的基本单位，线程是进程的子集，一个进程可以有很多线程，每条线程执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。



http 如何实现数据精准传输，以及相应的状态码

https默认端口，与https区别，证书

tcp/udp /三次握手

非递归遍历二叉树

设计一个大用户量的注册功能，判断昵称是否重复，userId的生成，入库操作

乐观锁与悲观锁，java中怎么实现的

java voliate





# 慧泽

三个线程同步，执行顺序

Java 类加载机制

JVM虚拟机

Spring Bean加载过程

计算对象大小的方法





# Java基础

对象的引用分为4种级别，由高到低分别是：强引用、软引用、弱引用和虚引用



可以作为GC Roots的对象

* 虚拟机栈（栈针中的局部变量表）中引用的对象
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象



对象在内存中的状态：

* 可达状态：有引用指向
* 可恢复状态：失去引用，垃圾回收机制开始回收时，回调用可恢复状态对象的finalize()方法（如果此方法让此对象重新获得引用，就会变为可达状态，否则变为不可达状态）
* 不可达状态：彻底失去引用









