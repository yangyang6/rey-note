1/清晰的知道自己想要的职位和薪水

2/清晰的知道自己的实力和能力是否能匹配这份薪水

3/面试情况未得到结果offer前不要轻易判断自己是否能够去那家公司上班





代码重构老纪的思路：

1.拆代码

2.拆步骤

3.流程一步步拆，哪些可以异步加线程

4.线程里面不能控制事务，不要数据库操作

5.拆完步骤再考虑把哪些步骤拆成抽象接口





机器学习：

监督学习/非监督学习（特征点学习，交易型数据当中）

机器学习【机器在少量样本数据的基础上找出一个公式来解决特定的问题】

通过尝试不同的权重值，使代价尽可能的低。但是还有一点很重要，只有在你拥有的数据对于解决实际问题有效的时候，机器学习才能适用。





### 操作系统

线程是操作系统能够进行运算调度的最小单元



### 数据库

Mysql MHA架构 - 脑裂问题，Master - Slave之间是基于Binlog的异步复制，也会导致主库机器宕机或者主库无法访问时，MHA切换的过程中可能导致数据丢失。

##### 解决主从同步数据丢失

加一个Binlog Server，它模拟Slave接受Binlog日志，主库每次的数据写入都需要接收到Binlog Server的Ack应答，才认为写入成功。在发生故障时，只需要从BinLog server拉取数据即可保证数据不丢失

##### MGR结合中间件高可用



##### SQLAdvisor数据库慢sql分析

##### Mysql闪回工具 MyFlash

也可以使用业界提供的解析binlog的库，然后进行SQL构造，其优秀的代表是binlog2sql

基于binlog event回滚是整体难点是在update的操作（insert 和 delete 其实就是两边做交换操作）



数据拆分、数据如何组合，中小公司推荐使用开源方案，例如Mysql官方推荐的Mysql router、360开源的数据库中间件altas







### Java基础

日期时间LocalDateTime

日期LocalDate

时间LocalTime



##### 基本数据类型

```
byte  ->   8 bits  -->1字节
char  ->   16 bit  -->2字节
short ->   16 bits -->2字节
int   ->   32 bits -->4字节
float ->   32 bits -->4字节
long  ->   64 bits -->8字节
```



##### 数组

一维数组的寻址公式，假设二维数组大小为m*n

``` 
a[k]_address = base_address + k * type_size
```

二~ 假设二维数组大小为m*n：

``` 
a[i][j]_address = base_address + (i * n+j)*data_type_size
```

三~ 假设三维数组大小为 m*n*q：

``` 
a[i][j][k]_address = base_address + (i*n*q + j*q + k)*data_type_size
```



<strong style="color:red">1.为什么类似ArrayList集合不存基本类型？</strong>

<strong style="color:red">2.哪些场景你更偏向用数组哪些地方用集合类型如ArrayList、LinkedList</strong>





##### 异步编程

CompletableFuture

##### 正则

零宽断言，手机号隐藏中间四位

```java
"(\\d{3})\\d{4}(\\d{4})","$1****$2")
```



##### 匿名内部类

<strong>为什么要持有外部类</strong>

* 当匿名内部类只是在外部类（主类）中使用时，匿名内部类可以不让外部类感受到他的存在，从而减少代码的维护工作
* 当匿名内部类持有外部类时，它就可以直接使用外部类中的变量，这样就可以很方便完成调用

##### 为什么静态内部类不会持有外部类的引用

匿名内部类是静态之后，所引用的对象或属性也必须是静态的， ?<strong>因此就可以直接从JVM的方法区获取到引用而无需持久外部对象了</strong>?



##### 对象大小的估算

Integer aa = new Integer(999)  ，对象aa的大小是16字节

对象大小 = 头【数组（4） 、 标记（8）、或对象数组（4）】 + 内容



##### 容器

对于业务开发，直接使用容器就足够了。但如果做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，可以考虑数组。



### Spring

spring.factories















### 网络

##### 协议

| HTTP1.1                                 | HTTP2      |
| --------------------------------------- | ---------- |
| 持久连接                                | 二进制分帧 |
| 请求管道化                              | 多路复用   |
| 增加缓存处理（新加字段如cache-control） | 头部压缩   |
| 增加host字段，支持断点续传等            | 服务器推送 |







### JVM

关于堆

堆大小 = 年轻代 + 老年代

年轻代 = Eden space(新生代) + from survivor + to survivor

对于高并发的缓存应用应该避免采用JVM的分代管理内存，或者可以说，GC内存回收机制的开销和效率并不能满足高并发情形下的内存管理的需求。由于JVM虚拟机的强制管理内存的限制，此时我们可以将对象序列化存储到<Strong>堆外</strong>(Off Heap)，来达到绕开JVM管理内存的目的，例如Ehcache、BigMemory等等第三方技术便是如此。或者改动JVM底层实现做到堆内存储免于GC









### 分布式

##### CAP

和钱相关的要保证强一致性，可以舍弃一些可用性

强一致性 - 刚性事务   SEATA AT模式

两阶段提交方式：

![image-20201017134138865](/Users/yangli/Library/Application Support/typora-user-images/image-20201017134138865.png)



弱一致性 - 柔性事务   BASE 最终一致性  SEATA Saga





##### 微服务

微服务每个服务配置对应不同的数据源

微服务依赖，循环依赖的问题：

> 解决服务依赖环的方案一般是，依赖倒置的设计模式。在分布式架构中可以找一个第三方服务来解决
>
> 或是把其中的依赖关系抽到一个第三方服务中，由这个第三方服务来做转发



##### 关于缓存

> 进程内缓存（堆内缓存）可以推荐Guava的LoadingCache

堆内内存 =  新生代 + 老年代 + 持久代

堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理。这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。

JAVA中可以通过<strong>-XX:MaxDirectMemorySize</strong>来指定最大的堆外内存的大小

<strong>缓存与数据库的一致性问题</strong>

* Cache Aside

  https://blog.csdn.net/wnvalentin/article/details/92761720

* Read Through

* Write Through

* Write Behind Caching



##### Redis

Redis-cluter的高可用、分片、可扩展 性能

https://www.cnblogs.com/tongxuping/p/12356766.html



>  避免缓存穿透：空值缓存和布隆过滤器

* 空值缓存：第一次查询 把数据库中未找到值保存在本地缓存中，第二次查直接从本地缓存中去拿就可以了，就不用再查数据库了

* 布隆过滤器：可以把database的数据的key值可以预先存到布隆过滤器里面去，然后在布隆过滤器中去过滤，如果发现布隆过滤器没有话再从redis取，redis没有的话再从数据库取



















大数据量的缓存或者支持分布式访问 可以考虑使用Redis

IO密集型的操作或调用可以适当增加线程数

对象之间的拷贝可以使用BeanUtils 这个类

分布式微服务监控Zipkin,Pinpoint,SkyWalking



### ASM

1.基于事件的API要快于基于对象的API，所需要的内存比较少，因为它不需要在内存中创建和存储用于表示类的对象树（SAX/DOM ）

2.基于事件的API，类转换实现要难些





### Git

``` shell
git reset --soft HEAD^
```





### Software

https://github.com/jgraph/drawio-desktop/releases/download/v13.6.2/draw.io-13.6.2.dmg





### Linux/Unix

当telnet host port 的时候 会出一个结果：Escape character is '^]'

^  相当于Ctrl键，ctrl + ] 就可以进入telnet 了

netstat -ntlp 

##### Unix：

netstat -AaLlnW

/usr/sbin/lsof -i

##### 

Linux进程间通信的几种主要手段

* 管道

* 消息队列

* 共享内存

* 套接字

* 信号

  > 列出所有信号： kill -l



### 调试

淘宝npm 镜像 cnpm，淘宝定制的cnpm（gzip压缩支持）命令行工具代替默认的npm

<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>





### 架构设计



##### 前端

weex

react-native



typescript

taro 小程序 （实际上是以react）





##### 微服务

使用场景划分 /  使用对象划分

Eureka如果想在开发环境其他公共服务，可以修改自己的spring.application.name=xxx-service





##### 事件溯源（Event Sourcing），读写分离（CQRS）与事件驱动设计（Event-Driven Design）



##### 高可用

5个9   （1-99.999%） * 365 * 24 * 60 = 5.256分钟 业务中断时间



##### 幂等性

幂等是一个数学与计算机学概念，常用于抽象代数中

> 幂等操作特点是其任意多次执行所产生的影响均与一次执行的影响相同





##### 网关

Apisix/Kong

开源面向云原生的网关，静态资源挂载?

https://www.cnblogs.com/chenyuanbo/p/10122977.html



##### 关于有状态的服务和无状态的服务

两个服务尽量不用耦合，尽量不要弄分布式事务，事务放到有状态的服务里面统一处理





##### 领域驱动设计

参考：https://tech.meituan.com/2017/12/22/ddd-in-practice.html

重构 从概念模型到代码模型，但提炼出的设计模型，并不具有实际的业务含义。

DDD：将数据和行为封装在一起，DDD中的限界上下文则完美匹配微服务的要求，可以将该限界上下文理解为一个微服务的进程。

将架构活动精简为三个层面：

* 业务架构 —  根据业务需求设计业务模块及其关系
* 系统架构 — 设计系统与子系统的模块
* 技术架构 — 决定采用的技术及框架



设计领域模型的一般步骤如下：

1.根据需求划分出初步的领域和限界上下文，以及上下文之间的关系；

2.进一步分析每个上下文内部，识别出哪些是实体，哪些是值对象；

3.对实体、值对象进行关联和聚合，划分出聚合的范畴和聚合跟

4.为聚合跟设计仓储，并思考实体或值对象的创建方式

5.在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构



##### 实体

> 当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）
>
> 例如：人的模拟，即认为是实体，因为每一个人是独一无二的，且其具有唯一标识（比如身份证）

在实践中建议将属性的验证放到实体中



##### 值对象

> 当一个对象用于对事物进行描述而没有唯一标识时，它被称作值对象（value object）
>
> 例如：颜色信息，我们只需要知道{"name":"黑色","css":"#00000"}这样的值信息就能够满足要求了，这避免了我们对标识追踪带来的系统复杂性

值对象很重要，在习惯了使用数据库的数据建模后，很容易将所有对象看作实体。使用值对象，可以更好地做系统优化、精简设计。

在实践中，需要保证值对象创建后就不能被修改，即不允许外部再修改其属性。在不同上下文集成时，会出现模型概念的公用，如商品模型会存在于电商的各个上下文中。在订单上下文中如果你只关注下单时商品信息的快照，那么将商品对象视为值对象是很好的选择。



##### DDD在工程上的实践

![image-20200914110624086](/Users/yangli/Library/Application Support/typora-user-images/image-20200914110624086.png)



##### 资源库

![image-20200914111650385](/Users/yangli/Library/Application Support/typora-user-images/image-20200914111650385.png)



将领域行为封装到领域对象中，将资源管理行为封装到资源库中，将外部上下文的交互行为封装到防腐层中。









### Book

Hadoop权威指南
Hadoop技术内幕：深入解析Hadoop Common和HDFS
Spark技术内幕
Hadoop技术内幕：Yarn
Spark大数据处理技术
Hive编程指南
Hbase企业级实战
Storm分布式实时计算模式
从paxos到zookeeper分布式一致性协议
Kafka源码剖析
数据仓库
Java编程思想（部分章节）
Java并发编程实战
深入理解java虚拟机
Java消息服务
Linux高性能服务器编程
Linux内核设计与实现
统计学习方法 
机器学习实战
大话设计模式
大型网站技术架构
memcache全面剖析
快学Scala
剑指offer