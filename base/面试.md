# 面试冲刺





## naver china

09:30 成都市高新区天府三街199号太平洋保险金融大厦A区. 11层 16层

java基础(多态、运算符优先级继承多态)和虚拟机，还有数据库索引和sql，分布式最终一致性，图的算法，多线程的锁，JUC，JVM底层实现，



总部在北京，大连、延吉也有分公司。成都这边是纯研发团队，主要负责 NAVER 服务，多种 Back-End 系统、云端平台服务开发业务的技术支持，以及全球化企业使用的合作服务 LINE Works 的全球 Delivery 开发中心业务。

要架构 B/S, C/S 模式都有，网络方面主要是以 TCP 为主，更上层的协议是以 HTTP, HTTPS, Websocket 为主。薪资待遇的话，没有定岗也不好定薪，我这边不方便给您一个确定的答复，多多理解~

###  

#### synchronized和lock的区别 

synchronized底层上看是JVM层面的锁，是Java关键字，通过monitor对象来完成。

Lock是API层面的锁，偏向于自主控制锁，粒度更细。





#### CountDownLatch（倒计时计算器）



#### 阻塞队列

BlockQueue







#### 信号量Semaphore

Semaphore是JDK提供的一个同步工具，它通过维护若干个许可证来控制线程对共享资源的访问。如果许可证剩余数量大于零时，线程则允许访问该共享资源；如果许可证剩余数量为零时，则拒绝线程访问该共享资源。Semaphore所维护的许可证数量就是允许访问共享资源的最大线程数量，所以，线程想要访问共享资源必须从Semaphore中获取到许可证







#### final finally finalized区别

final修饰变量，方法，类，修饰的类和方法不能被继承，修饰的变量不能被更改（俗称常量）

finally是异常处理类的一部分，它只能在try/catch语句块中，表示与对于的try语句块执行的情况下，finally所包含的语句块一定能被执行，final的用法比较特殊，会撤销之前的return语句，继续执行最后的final块中的代码

finalized是Object里面的方法，GC的时候会调用这个方法



#### 动态代理

代理模式侧重于控制访问，代理对象不会改变目标对象的职责和能力，它提供与目标对象相同的接口，但会增加相应的逻辑来控制访问目标对象。



* <Strong>jdk动态代理</strong>

  jdk动态代理实际上是运行时通过反射的方式来实现的，将代理的方法调用转到目标对象上，最终将目标对象生成的任何结果返回给调用方

  <strong>实现代理模式的流程：</strong>

  1.抽象出目标对象的接口

  2.实现接口InvocationHandler创建代理业务

  3.使用newProxyInstance创建代理对象

  4.业务处理



jdk动态代理它有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理的实例？ 答案就是CGlib

* <strong>cglib动态代理</strong>

  cglib是一个基于ASM字节码生成库，它允许我们在运行时对字节码进行修改和动态生成，CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类的方法的调用并顺势织入横切逻辑。







#### redis持久化

* RDB持久化

  RDB持久化是将某个时间点的Redis数据保存到一个RDB文件中，RDB持久化也叫做快照持久化

  Redis提供2个命令创建RDB文件，一个是SAVE，另一个是BGSAVE（一般用这个）

* AOF持久化

  AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库数据的





#### 分布式锁

为什么用分布式锁：

为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在分布式集群系统需要一种互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题

在很多场景，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁

* 基础数据库实现分布式锁
* 基于缓存（Redis等）实现分布式锁
* 基于ZK实现分布式锁





#### 

#### Spring的事务传播行为

Spring中有7种类型的事务传播行为，事务传播行为是Spring框架提供的一种事务管理方式

* Propagation.REQUIRED

  默认值，如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务

  

* Propagation.SUPPORTS

  如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行

  

* Propagation.MANDATORY

  如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常

* Propagation.REQUIRES_NEW

  重新创建一个新的事务，如果当前存在事务，延缓当前的事务

  

* Propagation.NOT_SUPPORTED

  以非事务的方式运行，如果当前存在事务，暂停当前的事务

  

* Propagation.NEVER

  以非事务的方式运行，如果当前存在事务，则抛出异常

  

* Propagation.NESTE

  如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务



对静态内部类.class调用toString方法



Top K问题等，



问到了如何多个进程(不是线程)执行临界区代码，



#### 如何把数组中的重复元素去掉然后按升序排序

冒泡加trim



一致性哈希算法，，，线程池，，Aop等



### 算法题

#### 统计连续子数组和等于指定值的次数

Map去实现



#### Top N/K问题



### JVM问题

#### 类加载机制

类的加载指将类的.class文件的二进制数据读入内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区中的数据结构（<strong style="color:red">这个看着有点绕呀</strong>）

![wps5F9E.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125941772-1913742708.png)

类加载器并不需要等到某个类被”首次主动使用“时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它

##### 类的生命周期

![wps257C.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125943209-1443333281.png)

* 加载

  加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

  1、通过一个类的全限定名来获取其定义的二进制字节流。

  2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

  3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

  加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而且在Java堆中创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

* 连接

  * <strong>验证</strong>

  这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

  * 准备

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配

  这个时候进行内存分配的仅包括类变量（static），而不包含实例变量，实例变量会在对象实例化随着对象一块分配到堆中

  如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量Value就会被初始化为ConstValue属性所指定的值

  * 解析

* 初始化

* 结束生命周期

  

##### JVM类加载机制

* 全盘负责

  当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入

* 父类委托

  先让父类加载器试图加载该类，只有在父类加载器无法加载该类时，才会尝试从自己的类路径中加载该类

* 缓存机制

  缓存机制会让所有加载的类都加入到缓存中去

  

##### 类的加载

Class.forName():将类的.class文件加载到JVM中之外，还会对类进行解释，执行类中的static块

ClassLoader.loadClass():只干一件事，就是将.class文件加载到JVM中，只有在newInstance的时候才会去执行static块



##### 双亲委派模型

一个类加载器收到加载请求的时候，首先会把请求委托给父加载器去完成，依次向上，因此所有类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类的时候，即无法完成该加载，子加载器才会尝试去加载该类



#### JVM内存结构

JVM内存结构主要有三大块：堆内存、方法区和栈，堆内存是JVM中最大的一块，由新生代与老年代组成，而年轻代内存又被分成三部分，Eden空间，From Survivor空间，To Survivor空间，默认情况年轻代是按照8：1：1分配的

方法区存储类信息、常量、静态变量等数据，是线程共享区域

栈又分为java虚拟机栈和本地方法栈主要用于方法的执行

![JUtH_20121024_RuntimeDataAreas_6_MemoryModel](https://images2015.cnblogs.com/blog/331425/201606/331425-20160623115840235-1252768148.png)



每个区域的作用：

* Java堆（Heap）

  Java堆是Java虚拟机所管理的内存最大的一块区域，几乎所有的对象实例都在这里分配内存，现在收集器基本都是采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等

  如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OOM异常

* 方法区（Method Area）

  方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

* 程序计数器（Program Counter Register）

  它是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器

  此内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域

* JVM栈（JVM Stacks）

  它是线程私有的，它的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型

* 本地方法栈（Native Method Stacks）

  本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到Native方法服务









### Mysql

#### Mysql的索引有哪些

* 数据结构角度

  1.B+树索引

  2.Hash索引

  3.FullText索引

  4.R-Tree

* 物理存储角度

  聚集索引

  非聚集索引

* 逻辑角度

  1.主键索引

  2.普通索引或单单列索引

  3.多列索引（复合索引）：最左前缀匹配

* 唯一索引或非唯一索引

* 空间索引



#### 什么是回表、索引覆盖

回表就是比如我们建立了一个索引(a,b)，但是要查的数据包括(a,b,c),这样查询的时候就需要进行回表操作

而如果我们查询的就是(a,b)这样查询就可以进行了，称为索引覆盖。 

<strong>需要说明的是覆盖索引必须要存储索引列的值，而Hash，空间索引和全文索引不存储列的值，所以mysql只能用B+ tree索引做索引覆盖</strong>





#### SQL基础

stu表

| id   | name |
| ---- | ---- |
| 1    | 张三 |
| 2    | 李四 |
| 3    | 王五 |

score表

| id   | s_id | score |
| ---- | ---- | ----- |
| 1    | 1    | 80    |
| 2    | 1    | 90    |
| 3    | 2    | 98    |
| 4    | 2    | 95    |

查出优生的结果（每颗成绩大于90分）

<code>select name from stu  as stu where not exists (select 1 from score as s where s.score <=90 and s.`s_id` = stu.id)
and exists (select 1 from score as s where s.`s_id` = stu.id)</code>





有两个编程题，一个是线程同步的，基本就是如何确保临界区，最多只有三个线程进入。

