# 面试冲刺





## naver china

09:30 成都市高新区天府三街199号太平洋保险金融大厦A区. 11层 16层

java基础(多态、运算符优先级继承多态)和虚拟机，还有数据库索引和sql，分布式最终一致性，图的算法，多线程的锁，JUC，JVM底层实现，



总部在北京，大连、延吉也有分公司。成都这边是纯研发团队，主要负责 NAVER 服务，多种 Back-End 系统、云端平台服务开发业务的技术支持，以及全球化企业使用的合作服务 LINE Works 的全球 Delivery 开发中心业务。

要架构 B/S, C/S 模式都有，网络方面主要是以 TCP 为主，更上层的协议是以 HTTP, HTTPS, Websocket 为主。薪资待遇的话，没有定岗也不好定薪，我这边不方便给您一个确定的答复，多多理解~

###  

#### synchronized和lock的区别 

synchronized底层上看是JVM层面的锁，是Java关键字，通过monitor对象来完成。

Lock是API层面的锁，偏向于自主控制锁，粒度更细。



#### 信号量Semaphore

Semaphore是JDK提供的一个同步工具，它通过维护若干个许可证来控制线程对共享资源的访问。如果许可证剩余数量大于零时，线程则允许访问该共享资源；如果许可证剩余数量为零时，则拒绝线程访问该共享资源。Semaphore所维护的许可证数量就是允许访问共享资源的最大线程数量，所以，线程想要访问共享资源必须从Semaphore中获取到许可证







#### final finally finalized区别

final修饰变量，方法，类，修饰的类和方法不能被继承，修饰的变量不能被更改（俗称常量）

finally是异常处理类的一部分，它只能在try/catch语句块中，表示与对于的try语句块执行的情况下，finally所包含的语句块一定能被执行，final的用法比较特殊，会撤销之前的return语句，继续执行最后的final块中的代码

finalized是Object里面的方法，GC的时候会调用这个方法



#### 动态代理

代理模式侧重于控制访问，代理对象不会改变目标对象的职责和能力，它提供与目标对象相同的接口，但会增加相应的逻辑来控制访问目标对象。



* <Strong>jdk动态代理</strong>

  jdk动态代理实际上是运行时通过反射的方式来实现的，将代理的方法调用转到目标对象上，最终将目标对象生成的任何结果返回给调用方

  <strong>实现代理模式的流程：</strong>

  1.抽象出目标对象的接口

  2.实现接口InvocationHandler创建代理业务

  3.使用newProxyInstance创建代理对象

  4.业务处理



jdk动态代理它有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理的实例？ 答案就是CGlib

* <strong>cglib动态代理</strong>

  cglib是一个基于ASM字节码生成库，它允许我们在运行时对字节码进行修改和动态生成，CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类的方法的调用并顺势织入横切逻辑。







#### redis持久化

* RDB持久化

  RDB持久化是将某个时间点的Redis数据保存到一个RDB文件中，RDB持久化也叫做快照持久化

  Redis提供2个命令创建RDB文件，一个是SAVE，另一个是BGSAVE（一般用这个）

* AOF持久化

  AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库数据的





#### 分布式锁

为什么用分布式锁：

为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在分布式集群系统需要一种互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题

在很多场景，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁

* 基础数据库实现分布式锁
* 基于缓存（Redis等）实现分布式锁
* 基于ZK实现分布式锁





#### 

#### Spring的事务传播行为

Spring中有7种类型的事务传播行为，事务传播行为是Spring框架提供的一种事务管理方式

* Propagation.REQUIRED

  默认值，如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务

  

* Propagation.SUPPORTS

  如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行

  

* Propagation.MANDATORY

  如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常

* Propagation.REQUIRES_NEW

  重新创建一个新的事务，如果当前存在事务，延缓当前的事务

  

* Propagation.NOT_SUPPORTED

  以非事务的方式运行，如果当前存在事务，暂停当前的事务

  

* Propagation.NEVER

  以非事务的方式运行，如果当前存在事务，则抛出异常

  

* Propagation.NESTE

  如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务



对静态内部类.class调用toString方法，

没啥技术含量



Top K问题等，



问到了如何多个进程(不是线程)执行临界区代码，如何把数组中的重复元素去掉然后按升序排序，一致性哈希算法，CountDownLatch，阻塞队列，线程池，，Aop等，技术面试自我感觉回答的比较好，



有两个编程题，一个是线程同步的，基本就是如何确保临界区，最多只有三个线程进入。



一、笔试，全英文，1小时，前面不定项选择，最后两道编程题，一道关于多线程同步器，一道算法题（堆排序）

二、技术面第1轮，问的问题有：1.印象最深的项目，2.笔试做错的题目，3.AQS，4.一致性hash，5.分布式锁，6.手写算法题统计连续子数组和等于指定值的次数。这轮完了后行政/HR说后面还有轮次，约了第二天下午。

三、第二天下午，等待技术第2轮面试官，说是韩国人，一直等面试官，等了1个小时没等到（好像开会），来了HR，相当于直接进入了HR面？HR疯狂给我介绍他们LINE项目（好像是类似微信的东西，但是我投的是云存储方向），我表示只对云存储感兴趣（到这里应该就凉了），后面HR谎称云存储面试官忙，约下次再面，并且通过微信或QQ的方式联系我（一看就是假的），来面试连技术人员都没见着感觉有点不爽。



英文自我介绍





