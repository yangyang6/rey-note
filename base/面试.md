# 面试冲刺



## naver china

09:30 成都市高新区天府三街199号太平洋保险金融大厦A区. 11层 16层

java基础(多态、运算符优先级继承多态)和虚拟机，还有数据库索引和sql，分布式最终一致性，图的算法，多线程的锁，JUC，JVM底层实现，



总部在北京，大连、延吉也有分公司。成都这边是纯研发团队，主要负责 NAVER 服务，多种 Back-End 系统、云端平台服务开发业务的技术支持，以及全球化企业使用的合作服务 LINE Works 的全球 Delivery 开发中心业务。

要架构 B/S, C/S 模式都有，网络方面主要是以 TCP 为主，更上层的协议是以 HTTP, HTTPS, Websocket 为主。薪资待遇的话，没有定岗也不好定薪，我这边不方便给您一个确定的答复，多多理解~

###  

#### synchronized和lock的区别 

synchronized底层上看是JVM层面的锁，是Java关键字，通过monitor对象来完成。

Lock是API层面的锁，偏向于自主控制锁，粒度更细。





#### CountDownLatch（倒计时计算器）



#### 阻塞队列

BlockQueue







#### 信号量Semaphore

Semaphore是JDK提供的一个同步工具，它通过维护若干个许可证来控制线程对共享资源的访问。如果许可证剩余数量大于零时，线程则允许访问该共享资源；如果许可证剩余数量为零时，则拒绝线程访问该共享资源。Semaphore所维护的许可证数量就是允许访问共享资源的最大线程数量，所以，线程想要访问共享资源必须从Semaphore中获取到许可证







#### final finally finalized区别

final修饰变量，方法，类，修饰的类和方法不能被继承，修饰的变量不能被更改（俗称常量）

finally是异常处理类的一部分，它只能在try/catch语句块中，表示与对于的try语句块执行的情况下，finally所包含的语句块一定能被执行，final的用法比较特殊，会撤销之前的return语句，继续执行最后的final块中的代码

finalized是Object里面的方法，GC的时候会调用这个方法



#### 动态代理

代理模式侧重于控制访问，代理对象不会改变目标对象的职责和能力，它提供与目标对象相同的接口，但会增加相应的逻辑来控制访问目标对象。



* <Strong>jdk动态代理</strong>

  jdk动态代理实际上是运行时通过反射的方式来实现的，将代理的方法调用转到目标对象上，最终将目标对象生成的任何结果返回给调用方

  <strong>实现代理模式的流程：</strong>

  1.抽象出目标对象的接口

  2.实现接口InvocationHandler创建代理业务

  3.使用newProxyInstance创建代理对象

  4.业务处理



jdk动态代理它有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理的实例？ 答案就是CGlib

* <strong>cglib动态代理</strong>

  cglib是一个基于ASM字节码生成库，它允许我们在运行时对字节码进行修改和动态生成，CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类的方法的调用并顺势织入横切逻辑。







#### redis持久化

* RDB持久化

  RDB持久化是将某个时间点的Redis数据保存到一个RDB文件中，RDB持久化也叫做快照持久化

  Redis提供2个命令创建RDB文件，一个是SAVE，另一个是BGSAVE（一般用这个）

* AOF持久化

  AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库数据的





#### 分布式锁

为什么用分布式锁：

为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在分布式集群系统需要一种互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题

在很多场景，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁

* 基础数据库实现分布式锁

* 基于缓存（Redis等）实现分布式锁

  不太推荐，redis的锁用来做限流还是可以

* 基于ZK实现分布式锁





#### 

#### Spring的事务传播行为

Spring中有7种类型的事务传播行为，事务传播行为是Spring框架提供的一种事务管理方式

* Propagation.REQUIRED

  默认值，如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务

  

* Propagation.SUPPORTS

  如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行

  

* Propagation.MANDATORY

  如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常

* Propagation.REQUIRES_NEW

  重新创建一个新的事务，如果当前存在事务，延缓当前的事务

  

* Propagation.NOT_SUPPORTED

  以非事务的方式运行，如果当前存在事务，暂停当前的事务

  

* Propagation.NEVER

  以非事务的方式运行，如果当前存在事务，则抛出异常

  

* Propagation.NESTE

  如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务



对静态内部类.class调用toString方法



Top K问题等，



问到了如何多个进程(不是线程)执行临界区代码，



#### 如何把数组中的重复元素去掉然后按升序排序

冒泡加trim



一致性哈希算法，，，线程池，，Aop等



### 算法题

#### 统计连续子数组和等于指定值的次数

Map去实现



#### Top N/K问题



### JVM问题

#### 类加载机制

类的加载指将类的.class文件的二进制数据读入内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区中的数据结构（<strong style="color:red">这个看着有点绕呀</strong>）

![wps5F9E.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125941772-1913742708.png)

类加载器并不需要等到某个类被”首次主动使用“时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它

##### 类的生命周期

![wps257C.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160621125943209-1443333281.png)

* 加载

  加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

  1、通过一个类的全限定名来获取其定义的二进制字节流。

  2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

  3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

  加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而且在Java堆中创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

* 连接

  * <strong>验证</strong>

  这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

  * 准备

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配

  这个时候进行内存分配的仅包括类变量（static），而不包含实例变量，实例变量会在对象实例化随着对象一块分配到堆中

  如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量Value就会被初始化为ConstValue属性所指定的值

  * 解析

* 初始化

* 结束生命周期

  

##### JVM类加载机制

* 全盘负责

  当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入

* 父类委托

  先让父类加载器试图加载该类，只有在父类加载器无法加载该类时，才会尝试从自己的类路径中加载该类

* 缓存机制

  缓存机制会让所有加载的类都加入到缓存中去

  

##### 类的加载

Class.forName():将类的.class文件加载到JVM中之外，还会对类进行解释，执行类中的static块

ClassLoader.loadClass():只干一件事，就是将.class文件加载到JVM中，只有在newInstance的时候才会去执行static块



##### 双亲委派模型

一个类加载器收到加载请求的时候，首先会把请求委托给父加载器去完成，依次向上，因此所有类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类的时候，即无法完成该加载，子加载器才会尝试去加载该类



#### JVM内存结构

JVM内存结构主要有三大块：堆内存、方法区和栈，堆内存是JVM中最大的一块，由新生代与老年代组成，而年轻代内存又被分成三部分，Eden空间，From Survivor空间，To Survivor空间，默认情况年轻代是按照8：1：1分配的

方法区存储类信息、常量、静态变量等数据，是线程共享区域

栈又分为java虚拟机栈和本地方法栈主要用于方法的执行

![JUtH_20121024_RuntimeDataAreas_6_MemoryModel](https://images2015.cnblogs.com/blog/331425/201606/331425-20160623115840235-1252768148.png)



每个区域的作用：

* Java堆（Heap）

  Java堆是Java虚拟机所管理的内存最大的一块区域，几乎所有的对象实例都在这里分配内存，现在收集器基本都是采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等

  如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OOM异常

* 方法区（Method Area）

  方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

* 程序计数器（Program Counter Register）

  它是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器

  此内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域

* JVM栈（JVM Stacks）

  它是线程私有的，它的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型

* 本地方法栈（Native Method Stacks）

  本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到Native方法服务



#### GC算法和垃圾回收器

算法：

##### 标记 - 清楚

##### 复制

##### 标记 - 压缩

##### 分代收集算法

垃圾回收器：

##### Serial收集器

​	串行收集器是最古老，最稳定，效率比较高的收集器。只使用一个线程去回收，新生代使用复制算法，老年代使用标记-压缩算法。垃圾收集的过程中会Stop the World

##### ParNew

​	Serial收集器的多线程版本，新生代并行，老年代串行

##### CMS

​	一种以获取最短回数-停顿时间为目标的收集器，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）

##### G1

​	与CMS收集器相比G1收集器有以下特点：

 * 空间整合

   G1采用标记-压缩算法，不会产生内存空间碎片

	* 可预测停顿



### Mysql

#### Mysql的索引有哪些

* 数据结构角度

  1.B+树索引

  2.Hash索引

  3.FullText索引

  4.R-Tree

* 物理存储角度

  聚集索引

  非聚集索引

* 逻辑角度

  1.主键索引

  2.普通索引或单单列索引

  3.多列索引（复合索引）：最左前缀匹配

* 唯一索引或非唯一索引

* 空间索引



#### 什么是回表、索引覆盖

回表就是比如我们建立了一个索引(a,b)，但是要查的数据包括(a,b,c),这样查询的时候就需要进行回表操作

而如果我们查询的就是(a,b)这样查询就可以进行了，称为索引覆盖。 

<strong>需要说明的是覆盖索引必须要存储索引列的值，而Hash，空间索引和全文索引不存储列的值，所以mysql只能用B+ tree索引做索引覆盖</strong>





#### SQL基础

stu表

| id   | name |
| ---- | ---- |
| 1    | 张三 |
| 2    | 李四 |
| 3    | 王五 |

score表

| id   | s_id | score |
| ---- | ---- | ----- |
| 1    | 1    | 80    |
| 2    | 1    | 90    |
| 3    | 2    | 98    |
| 4    | 2    | 95    |

查出优生的结果（每颗成绩大于90分）

<code>select name from stu  as stu where not exists (select 1 from score as s where s.score <=90 and s.`s_id` = stu.id)
and exists (select 1 from score as s where s.`s_id` = stu.id)</code>





有两个编程题，一个是线程同步的，基本就是如何确保临界区，最多只有三个线程进入。







### 内存泄漏

在java中内存泄漏就是存在一些被分配的对象，

首先这些对象是可达的，即在有向图中，存在通路可以与其连接；

其次，这些对象是无用的，即程序以后不在使用这些对象





### 什么是线程死锁，如何解决

产生死锁的条件有四个：

* 互斥条件：所谓互斥就是进程在某一时间内独占资源
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
* 不剥夺条件：进程已获得资源，在未使用之前，不能强行剥夺
* 循环等待条件：若干进程之前行程头尾相连的循环等待资源关系





# 腾铭惠商集团

### rocketmq消息一致性

rocketmq最新版本之后支持事务消息保持数据的最终一致性

事务消息可以保证本地事务和发送消息之间的原子性

Half（Prepare） Message

Message Status Check







### 你所知道的锁

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png)





### springboot启动流程

### hystrix，ribbon，feign调用时长







# 美团面试冲刺

### 单例模式

手写几种：

1.饿汉式

2.懒汉式

3.双重校验锁

4.枚举



##### String和Stringbuilder/StringBuffer

String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且大量浪费有限的内存空间。

StringBuilder/StringBuffer 在修改的时候不会产生新的未使用的对象

StringBuilder 线程不安全的

StringBuffer 线程安全的





排序算法会哪些，

jvm了解多少



##### 线程池的使用，线程池几个参数的意义

* corePoolSize

* maxPoolSize
* keepAliveTime
* allowCoreThreadTimeout
* queueCapacity

1.当线程数小于核心线程数时，创建线程

2.当线程数大于核心线程数时，且任务队列未满时，加入任务队列

3.当线程数大于核心线程数时，且任务队列已满

​		1.若线程数小于最大线程数，则创建线程

​		2.若线程数大于最大线程数，则抛出异常，拒绝任务



MQ的会哪些，怎么确实MQ消息是否消费完，阻塞队列的原理，

ConcurrentHashMap的原理以及1.7版本和1.8版本的不同。

3.现场二面主要问项目经验，在项目中担当什么角色，发挥了什么重要作用。



美团一面：

1.设计模型（单例模式）； 

2.数据结构，手撕链表，实现单向链表反转；

3.数据库是怎么搭建的；

4.数据库用的哪些实体 ；

##### 每个实体之间关系(外键，中间表)；

一对一

一对多

多对多



6.MySql索引；

7.Redis的理解；

8.Redis和Mysql的区别；

9.Redis用什么命令解决同时拿出多条数据；

10.Maven+SVN （解决出现同步冲突）；

11.FreeMaker的理解；

12.项目中遇到的问题怎么解决的；

13.Nginx，zookeper等了解过吗？



美团面试了两次吧，都是需要手写代码，不过一般问题不会很难，就是类似于实现一个死锁，或者排序算法之类的。但是问的问题的话我感觉没怎么根据简历上的项目问，主要还是看面试官想问什么吧。两次面试问的题基本上都不一样。

面试官的问题：

问tomcat的类加载机制，一个tomcat中多个项目的话，项目间的隔离是如何实现的。

答主要还是双亲委派机制吧，但是tomcat的加载机制和一般的jvm的加载顺序是不一样的，当时不是很清楚，所以没有完全对。

面试的整个过程问的问题还是比较基础的，其中有一个环境让你当场手写代码，思想大概就是用动态规划求最长公共子串。





##### 最长公共子串

*答*用动态规划。



一面是基础面，主要方向是线程池，string、stringbuffer，stringbuilder的区别，数据库索引，hashmap原理，linux指令，性能排查；二面结合项目谈架构，谈亮点，string算法考察，写一个单例模式。



1：一面：手写堆排序，笔试一道题+数据库+计算机网络

2：二面：问项目





# 国信杰云

聊的还是比较有意思的





# 质数斯达克

1.多线程用过没，具体场景

2.线程池参数介绍

##### ConcurrentHashMap 红黑树是怎么扩容

染色，左旋或右旋？



4.讲下公平锁/非公平锁的实现

5.zk 选举机制，paxos算法介绍下

##### 布隆过滤器

##### Netty为什么快

##### CMS/ParNew/G1垃圾回收区别

##### myiasm/innodb 应用场景



##### mysql5.6 mysql5.7 事务隔离级别方面的提升

Mysql5.7通过避免为只读事务分配事务ID，不为只读事务分配回滚段，减少锁竞争等多种方式，优化了只读事务的开销，提高了数据库的整体性能



##### 你所知道的引用类型

* 软引用
* 强引用
* 弱引用
* 虚引用

##### CompletableFuture





# 中建电商

##### 计算机网络相关

##### spring相关面试题，具体的使用方法和应用场景

##### MQ相关面试题，具体的使用方法和应用场景

##### spring事务传递，源码如果实现的

##### 1-100 三个线程，交替输出，保证顺序

```java
/**
 * 1-100，3个线程交替输出
 * synchronized实现方式
 */
public class OutPutThreadTest1 implements Runnable {
    private static Object lock = new Object();
    private static int count = 0;
    int no;
    public OutPutThreadTest1(int no) {
        this.no = no;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (lock) {
                if (count > 100) {
                    break;
                }
                if (count % 3 == this.no) {
                    System.out.println(this.no + "--->" + count);
                    count++;
                } else {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                lock.notifyAll();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(new OutPutThreadTest1(0));
        Thread t2 = new Thread(new OutPutThreadTest1(1));
        Thread t3 = new Thread(new OutPutThreadTest1(2));
        t1.start();
        t2.start();
        t3.start();
        t1.join();
        t2.join();
        t3.join();
    }
}
```



### Linux和TCP等偏底层的问题

##### TCP与UDP区别

1.UDP不需要连接，远地的主机在收到UDP报文后也不需要给出任何建议，对应的协议有DNS、TFTP、DHCP、NFS、SNMP等；TCP是面向连接的服务，在传输数据之前必须先建立连接，数据传输完成后要释放连接，对应的应用层协议主要有SMTP、TELNET、HTTP、FTP等

2.TCP提供可靠的传输（有序、无差错、不丢失、不重复），UDP提供不可靠的传输

3.TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销

4.TCP提供拥塞控制和流量控制；UDP不提供拥塞控制和流量控制



##### 多线程如何同步【质数斯达克好像也遇到这个问题】

临界区、互斥区、事件、信号量四种方式















##### JVM内存模型

##### mysql，dubbo和其他一些组件要理解到底层实现和源码层面



##### 深拷贝和浅拷贝

##### default关键字

##### session过期与持久化











# 美团

​	1.自我介绍

 2. 实现一个简单异步事件框架算法，comsum，producter

    异步事件直接用锁实现，生产者消费者并不适用于任何异步场景

    

##### 手写代码，将一个数字字符串，用模拟的方式转换成int数字。

利用ASCII码辅助计算

str.charAt(i) - '0'



##### 求二叉树最长子结构

https://www.cnblogs.com/yangtong/p/6687078.html



##### 简单介绍二叉查找树，红黑树，B树，B+树性质

二叉查找树也叫二叉搜索树

红黑树：

1.每个节点都是红色或黑色

2.树的根始终是黑色的

3.没有两个相邻的红色节点

4.从节点（包括根）到其任何后代NULL节点的每条路径都具有相同数量的黑色节点







​	6.手推红黑树查找，删除

​	7. B树，B+树在数据库存储中的作用(有关索引)

	8. 数据库索引的分类，优化方式(聚簇索引，非聚簇索引，覆盖，复合索引等等的概念)



##### MyISAM 和InnoDB 的区别，实现方式。 





##### 设计模式，解释了几个常用的 

观察者模式、代理模式 【认真搞通】



​	12.HTTP协议 

​	13.一个网站请求从客户端到服务器端的过程 

​	14.JVM，内存模型，GC，类加载器，反射等等的知识。 

​	15.Spring框架的启动流程

​	16.Sring框架IOC和AOP的实现原理，写了一个简易的IOC和一个AOP 

​	17.了解redis的特性，平时是否有使用，使用了哪些数据结构，使用redis做了什么功能等等。 

​	18.集合框架的知识，hashmap，ArrayList，LinkedList源码相关知识，基本整个介绍了一遍，与hastable，concurrenthashmap相互的关联和区别 

​	19.synchronized与lock的区别

​	20.java中的锁，偏向，轻，重，的转换

一、简答题

1.浏览器访问一个网址的时候都有哪些过程（还要了解DNS查找的过程）

2.tcp三次握手，四次分手

二、编程题

1.二分查找

2.树的中序遍历

三、智力题

给你一个5L和3L桶，水无限多，怎么到出4L

## 二面

面试官问我觉得一面面的怎么样，我。。。。然后就看我做的试卷，我竟然连二分查找都写错，面试官说不对，然后我改了改就好了，然后面试官就问还有什么可以优化的地方吗？我只说出来一个。。然后又是自我介绍，说项目，问项目，问基础。差不多也是40分钟。

## 三面

过了几天，收到3面邮，应该是部门boss，也是自我介绍，然后出了两个题。

1）一个n*n的矩阵，按副对角线打印

2）4个瓶盖换1瓶酒，要和150瓶酒，他自己最少多少瓶？然后问了职业规划。感觉有1个小时。





有些我记不清了，大概记得的就这些

一面：

  1.给了一道编程题，从方格中的某一点怎么去到另外的点，有多少种走法

  2.数据库联合索引，比如用的是A_B_C,给出几种场景，问在搜索的时候会什么时候会用到索引，讲讲一般怎么对数据库进行优化和explain的用法



 #####  Integer t = null; int m=t; System.out.println(t) 其实考的是拆箱和装箱，再编译阶段是把字节码加进去，真正进行拆装箱的对坐还是再运行上

```java
Integer t = null;
int m = t;             //执行到这里就报错
System.out.println(t);
```

局部变量表和操作数栈里面的操作，通过javap去反编译查看



##### error和Exception区别 列举几个常见的错误









二面：

 1.死怼虚拟机，新生代和老年代的区别究竟是什么？垃圾回收器的算法有哪些？垃圾回收期的名字有哪些？stop-the-world究竟干嘛啦

2.数据库的索引为什么用树，对数据库有没有什么了解

3.说说集合有哪几种？hashSet的底层是什么？它不安全再哪里？hashmap为什么不安全？（一定要把那2中情况说清楚，环出现了会有什么后果）？如果让你来做，怎么在不加锁的前提下保证它的安全？？

4.JMQ是怎么保证我一定会收到别人发的消息

5.nio和aio的区别，一定要知道的很清楚，所有的细节

6.new一个线程池的参数

7.2个同步shopId让我来做同步怎么同步

##### 1000000个数，找K个最大

堆排序

9.快速排序

10.spring涉及到的设计模式

三面：

1.了解分布式锁吗，知道怎么用吗

2.知道项目中用到的远程框架它是怎么报警的，比如它怎么能在web页面进行监控，数据怎么上去的，，worker的底层吗，zooker是个什么东西，elastic是个啥

3.平常怎么进行mysql的优化

4.还出了一个概率题，比较简单，我就不说了

5.string是在新生代还是老年代还是永久代，用的虚拟机是什么版本的

6.2个同步shopId让我来做同步怎么同步

7.ibatis和mybatis的不同

8.redis的2中持久化方式

9.除了jsf还了解什么远程框架，说说对比







