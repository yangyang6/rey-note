# 数据结构和算法

### 时间复杂度（全程渐进时间复杂度）

O(logn)：对数之间是可以相互转换的

复杂度量级（按数量级递增）：可以分为多项式量级和非多项式量级【O(2^n)和O(n!)】

<img src="https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg?" alt="img" style="zoom:50%;margin-left:-10px;" />

非多项式问题叫做NP问题

O(nlogn)：归并排序、快速排序



<strong>int *p变量名叫p，类型为int *，可以存放一个int数据的地址</strong>



### 数组

> 数组和链表的差别？

数组支持随机访问，根据下标随机访问的时间复杂度是O(1)

链表适合插入和删除，时间复杂度是O(1)，链表的查找不能通过类似数组的寻址公式去快速查找，时间复杂度是O(n)

 

##### 数组的插入

<strong style="color:red">低效的插入</strong>就是先遍历到要插入的位置K，再移动后面的元素

如何数组中存储的数据是没有任何规律的，如果要插入到第K个位置，可以想一个简单的办法是直接将K的元素搬到最后，把新的元素直接放入第K个位置

##### 数组的删除

<strong style="color:red">低效的删除</strong>就是删除第K个位置，然后补齐不连续的空间

还有更好的方案是可以记录下已经删除的数据，每次的删除操作并不是真正的搬移数据，只是记录数据已被删除。当数据没有更多空间存储的时候，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移



##### 容器

对于业务开发，直接使用容器就足够了。但如果做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，可以考虑数组。

##### 数组

一维数组的寻址公式，假设二维数组大小为m*n

``` 
a[k]_address = base_address + k * data_type_size
```

二~ 假设二维数组大小为m*n：

``` 
a[i][j]_address = base_address + (i * n+j)*data_type_size
```

三~ 假设三维数组大小为 m*n*q：

``` 
a[i][j][k]_address = base_address + (i*n*q + j*q + k)*data_type_size
```



<strong style="color:red">1.为什么类似ArrayList集合不存基本类型？</strong>

<strong style="color:red">2.哪些场景你更偏向用数组哪些地方用集合类型如ArrayList、LinkedList</strong>



### 链表

##### 单链表

<img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg?" alt="img" style="zoom:50%;margin-left:-10px;" />



##### 循环链表

<img src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg?" alt="img" style="zoom:50%;margin-left:-10px;" />

<strong style="color:orange">约瑟夫问题</strong>



##### 双向链表

<img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="img" style="zoom:50%;margin-left:-10px;" />

从结构上来看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入与删除等操作都比单链表简单、高效。





### 堆

##### 如何实时地统计业务接口的99%的响应时间?

两个堆

