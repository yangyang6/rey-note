# 基础构建模块

### 同步容器类

类似Vector和HashTable

同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。容器上常见的符合操作包括：迭代（反复访问元素，直到遍历容器中所有元素）、跳转（根据指定顺序找到当前），以及条件运算



在设计同步容器类的迭代器时并没有考虑并发修改问题，并且它们表现出的行为是”及时失败（fail-fast）“的，这意味着当它们发现容器在迭代过程中被修改时，就会抛出ConcurrentModificationException异常



它们的实现方式是 将计数器的变化（modCount）与容器关联起来





信号量（Semaphore）、栅栏（Barrier）以及闭锁（Latch）



### 并发容器

ConcurrentHashMap替代了HashMap

​	1.8之前使用了一种加锁更细的加锁机制 —— 分段锁

CopyOnWriteArrayList替代了ArrayList

​	写入时复制，在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。

​	注意使用：仅当迭代操作远远多于修改操作时，才应该使用”写入时复制“容器

​	使用场景：比如事件通知消息系统

JDK1.5新增了新的容器类型，Queue和BlockQueue





# 结构化并发应用程序



##### 执行策略

通过将任务的提交与执行解耦开来



##### 线程池

”在线程池中执行任务“比“为每一个任务分配一个线程”优势更多，通过重用现有的线程而不是创建新的线程，可以在处理多个请求分摊在线程创建和销毁过程中产生的巨大开销

* newFixedThreadPool，将创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量
* newCachedThreadPool，将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制
* newSingleThreadExecutor，是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSingleThreadExecutor能确保依照任务在队列中顺序来串行执行（例如FIFO、LIFO、优先级）





国内线程池设置：

CPU型任务：CPU核心数+1

IO型任务：CPU核心数*2



