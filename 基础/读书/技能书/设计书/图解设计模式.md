是不是感觉好久都没用过abstract 抽象类了？

类图      —  静态的关系

时序图  —  动态行为



不要只使用具体类来编程，要优先使用抽象类和接口来编程



## 适应设计模式

### Iterator模式

将for循环变量 i 作用抽象化、通用化后形成的模式

遍历与实现分离，

1.表示    2.遍历



### Adapter模式

用电源转换头（适配器）形象的比喻这个模式

Adapter模式有以下两种：

* 类适配器（使用继承的适配器）
* 对象适配器（使用委托的适配器）

相似的设计模式，Bridge模式

Adapter模式用于连接接口（API）不同的类，而Bridge模式用于连接类的功能层次结构与实现层次结构





##  交给子类

### Template Method模式

在父类中定义处理流程的框架，在子类中实现具体处理的模式

优点：父类的模板方法中编写了算法，因此无需在每个子类中再编写算法

AbstractClass角色（抽象类）：必须实现处理的流程

ConcreteClass（具体类）

相关设计模式：

Factory Method

Strategy模式

子类具有实现在父类中所声明的抽象方法的责任。



### Factory Method模式





## 生成实例

### Singleton模式

唯一实例

### Prototype模式

通过复制生成实例

* 对象种类繁多，无法将它们整合到一个类时



Object类自带本地方法clone()

### Builder模式

组装复杂的实例

### Abstract Factory模式

将关联零件组装成产品



### Bridge 模式

将类的功能层次结构与实现层次结构分离

继承是强关联的，委托是弱关联

### Strategy模式

整体地替换算法




### Composite模式

能够使容器与内容具有一致性

在视窗系统中，一个窗口可以含有一个子窗口，这就是composite模式的典型应用

模式类似的应用：文件系统、HTML标签系统里面的<ul>,<od>之类的关系作用



### Decorator模式

不断地为对象添加装饰的设计模式

Decorator模式的主要目的是通过添加装饰物来增加对象的功能。不修改被装饰的类即可增加功能

Decorator模式使用了委托，使类之间形成了弱关联关系

**缺点：**导致程序中增加许多功能类似的很小的类



### Visitor模式

访问数据结构并处理数据



**开闭原则**

对扩展是开放的

对修改是关闭的  —— 其实对于实体来说加字段，对于实现类方面加方法就是扩展方式吧



### Chain of Responsibility模式

将多个对象组成一条职责链，然后按照它们在职责链上的顺序一个一个地找出到底应该谁来负责处理

Chain of Responsibility 模式最大的优点就在于它弱化了发出请求的人（Client角色）和处理请求的人（ConcreteHandler角色），然后请求会在职责链中传播，直到某个ConcreteHandler角色处理该请求



### Facade 模式

### Mediator模式

要调整多个对象之间的关系时，就需要用到Mediator模式了。即不让各个对象之间相互通信，而是增加一个仲裁者角色，让他们各自与仲裁者通信。然后，将控制显示的逻辑处理交给仲裁者负责。





### Observer模式

适用于根据对象状态进行相应处理的场景

利用抽象类和接口从具体类中抽出抽象方法

在将实例作为参数传递至类中，或者在类的字段中保存实例时，不使用具体类型，而是使用抽象类型和接口





### State模式

用类表示状态

可以减少if语句判断具体的发生条件

分而治之的思想





### FlyWeight模式

使用内存多的对象就是”重“对象，使用内存少的对象就是”轻“对象

通过尽量共享实例来避免new出实例



###  Proxy模式

代理人，代替别人进行工作的人



### Command类





设计模式分类：

![image-20220722160616639](/Users/yangli/Library/Application Support/typora-user-images/image-20220722160616639.png)

