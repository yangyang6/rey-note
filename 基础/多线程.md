#  多线程



<strong>HashMap类</strong>

首先HashMap是线程不安全的，其主要体现：

1.在JDK1.7中，在多线程环境下，扩容时会造成环形链路或数据丢失

2.在JDK1.8中，在多线程环境下，会发生数据覆盖的情况（在putVal()中， 如果没有hash碰撞则直接插入元素）



<strong>ConcurrentHashMap类</strong>

1.在1.8之前采用分段锁，尽量降低同步锁的粒度

2.在1.8之后采用CAS思想代替冗杂的分段锁实现



CAS操作流程：

线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程，CAS问题又引出了下面的ABA问题



CAS采用乐观锁思想达到lock free，Unsafe的native方法，至于CAS的其他应用可以聊一聊Atomic元子类和一些无锁并发框架(如Amino)，提到ABA问题加分

ABA问题 就是线程1准备将变量的值由A变成B，但是线程2已经把变量A的值变成C，又由C替换成A，这样线程1去操作的时候发现变量的值仍为A，所以CAS成功



针对synchronized获取锁的方式，JVM使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为CAS轻量级锁，如果失败则就短暂自旋，防止线程被系统挂起。最后如果以上都失败则就升级为重量级锁



乐观锁的实现会加版本号来对对象记录操作标记，java就用到了AtomicStampedReference类

通过join()保证线程之间的执行顺序



<strong>synchronized</strong>

锁升级的过程：

JDK较早版本OS的资源 互斥量  用户态 -> 内核态的转换 重量级 效率较低

现代版本进行了优化：无锁 -> 偏向锁 -> 轻量级锁（自旋）->  重量级锁



<strong>volatile变量</strong>

* 保证了不同线程对它所修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对于其他线程来说是立即可见的（实现可见性）
* 禁止进行指令重排序
* volatile只能保证对单次读/写的原子性。i++这种操作不能保证原子性





<strong>ThreadLocal</strong>

以一种空间换时间的说法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题



单一设计原则：高内聚、低耦合。 程序设计模块与模块之间职责分离.

一致性问题解决方法：

排队（例如：锁、互斥量、管程、屏障等）  — 额外开销

投票（例如：Paxos、Raft等）		               — 额外开销

避免不一致：

例如ThreadLocal等

##### <font color="red">四种场景：</font>

持有资源 — 持有线程

线程一致

线程安全

并行计算



理解并发、竞争条件、临界区等概念





<strong>ReadWriteLock</strong>

如果用ReentrantLock是可以实现线程A在写数据的时候 B在读数据造成的数据不一致问题，

但是如果线程C、线程D也在读数据，数据是不会发生改变的，没有必要进行加锁，没有必要加锁，降低了程序性能

读写锁就是在读锁时共享的，写锁是独占的，提升了读写的性能





<strong>Semaphore</strong>

信号量是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源可以将它比作控制流量的红绿灯，车就是线程，驶入马路就表示线程正在执行，离开马路就表示线程执行完成，看到红灯就表示线程被阻塞，不能执行。

主要方法是acquire和release，acquire每调用一次，许可证数量就减1，如果许可证数量为0，则获取失败，线程进入AQS的等待队列中.





<strong>CountDownLatch</strong>

允许一个或多个线程等待其他线程完成操作



<strong>线程池</strong>

关于线程池线程的分配，要分为IO密集型和CPU密集型，具体介绍可以看相关资料，线程池设置线程数与CPU计算时间和IO操作时间的比例相关，在此可以引出一个配置线程池大小的原则 —— 阻抗匹配原则

> C = CPU数量
>
> P = CPU繁忙时间 / 总运行的时间   // 0<P<1
>
> T = 所需设置的线程数
>
> T = C / P

综上，CPU繁忙的程序越高，设置的线程越少，CPU繁忙时间越低，设置的线程数越高（但也不是无限设置）

线程池顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦





##### 可重入锁

可重入锁又名递归锁，在同一线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁

<img src="https://pic4.zhimg.com/80/v2-6226ac68b3e346614b6438bcfacd90f3_1440w.jpg?" alt="img" style="zoom:100%;margin-left:-10px;" />







高并发：问题，超员问题处理？



# 为什么会出现线程可见性问题？

![image-20220210144732243](/Users/yangli/Library/Application Support/typora-user-images/image-20220210144732243.png)

在编写并发程序时，我们一定要注意重排序对多线程执行结果的影响



死锁：

![image-20220210160315415](/Users/yangli/Library/Application Support/typora-user-images/image-20220210160315415.png)

形成死锁的四个必要条件：

* 互斥条件：线程（进程）对于所分配的资源具有排它性，即一个资源只能被一个线程（进程）占用，直到被该线程（进程）释放
* 请求与保持条件：一个线程（进程）因请求被占用资源而发生阻塞时，对已获得的资源保持不放
* 不剥夺条件：线程（进程）已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源
* 循环等待条件：当发生死锁时，所等待的线程（进程）必定会形成一个环路（类似于死循环），造成永久阻塞

如何避免死锁：我们只要破坏产生死锁的四个条件中的其中一个就行



创建线程的四种方式：

* 继承Thread类
* 实现Runnable接口
* 实现Callable接口
* 使用Executors工具类创建线程池

​		Executors提供了一系列工厂方法用于优先创建线程池，返回的线程池都实现了ExecutorService接口

​		

线程的start()和run()

​	start线程进入就绪状态

​	run方法当成一个main线程下的普通方法

![image-20220210171231257](/Users/yangli/Library/Application Support/typora-user-images/image-20220210171231257.png)

​	

线程五种基本状态：

* 新建（new）：新创建了一个线程对象
* 可运行（runnable）：线程对象创建后，当调用线程对象的start()方法后，该线程处于就绪状态，等待被线程调度选中，获取CPU的使用权
* 运行（running）：可运行状态（runnable）的线程获得了cpu时间片（timeslice），执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中
* 阻塞（block）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态

​		阻塞的情况分为三种：

​		1.等待阻塞：运行状态中的线程执行wait()方法，JVM会把该线程放入等待队列(waiting queue)中

​		2.同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程所占用），则JVM会把该线程放入锁池（lock pool）中，线程会进入同步阻塞状态

​		3.其他阻塞：通过调用线程的sleep()或join()或发出I/O请求时，线程会进行到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态

* 死亡（dead）：线程run()、main()方法执行结束，或者因异常退出run()方法，则该线程结束生命周期。死亡的线程不可再次复生





Java中用到的线程调度算法是什么？

有两种调度模型：分时调度模型和抢占式调度模型



线程调度器（Thread Scheduler）、时间分片（Time Slicing） 

线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现

时间分片是指将可用的CPU的时间分配给可用的Runnable线程的过程。分配CPU的时间可以基于线程优先级或者线程等待的时间



线程同步以及线程调度相关的方法：

* wait()：使一个线程处于等待（阻塞）状态，并且**释放所持有的对象的锁**
* sleep()：使一个正在运行的线程处于睡眠状态
* notify(): 唤醒一个处于等待状态的线程，由JVM确定唤醒哪个线程，而且与优先级无关
* notifyAll(): 唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态



wait()、notify()、notifyAll()方法定位在Object中，因为线程完全可以持有很多锁



##### JAVA实现多线程之间的通信与协作

可以通过中断 和 共享变量的方式

synchronized加锁的线程 的Object类的wait()、notify()、notifyAll()

ReetranLock类加锁的线程 的Condition类的await()、signal()、signalAll()





无界队列：LinkedBlockingQueue

有界队列：ArrayBlockingQueue





### synchronized关键字

JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销

访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁。

**自旋**

线程阻塞涉及到用户态和内核态切换的问题，既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞。

**多线程中synchronized锁升级的原理是什么？**

在锁对象的对象头里面有一个threadid字段，在第一次访问的时候threadid为空，jvm让其持有偏向锁，并将threadid设置为线程id，再次进入的时候会先判断threadid是否与其线程id一致，如果一致则可以直接使用其对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就把锁从轻量级锁升级为重量级锁。



synchronized、volatile、CAS比较

1) synchronized是悲观锁，属于抢占式，会引起其他线程阻塞
2) volatile提供多线程共享变量可见性和禁止指令重排序优化
3) CAS是基于冲突检测的乐观锁（非阻塞）

synchronized和ReentrantLock 都是可重入锁

volatile 常用于多线程环境下的单次操作（单次读或单次写）



死锁：两个或两个以上的线程互相争夺资源而造成的一种互相等待的现象，若无外力作用，它们将无法推进下去。

活锁：任务或者执行者没有被阻塞，由于某种条件没有满足，导致一直重复尝试，失败，尝试，失败
