# 数据模型与查询语言

NoSQL：

* 比关系数据库更好的扩展性需求，包括支持超大数据集或超高写入吞吐量





大多数关系型数据库系统可以在几毫秒内执行Alter Table语句，Mysql则需要注意，它执行Alter table时会把现在的整张表复制，因而当表很大时可能会需要几分钟甚至几个小时的停机时间，尽管现在有各种辅助工具可以解决这个限制。



数据库MapReduce查询：

PG：

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220314173709345.png" alt="image-20220314173709345" style="zoom:50%;margin-left:-2px" />



MongoDB：

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220314174222485.png" alt="image-20220314174222485" style="zoom:50%;margin-left:-2px" />



<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220314174514890.png" alt="image-20220314174514890" style="zoom:50%;margin-left:-2px" />









# 数据存储与检索

每次写数据时，需要更新索引，因此任何类型索引通常会降低写的速度

### 哈希索引

数据库新增数据由于是追加，所以hash索引存储是数据偏移量

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220315110556236.png" alt="image-20220315110556236" style="zoom:50%;margin-left:-2px" />



追加和分段主要是顺序写，它通常比随机写入快很多，特别是旋转性磁盘上。在某种程度上，顺序写入在基于闪存的固态磁盘（Solid state drives，SSD）上也是适合的。



SSTables（排序字符串表）

LSM-Tree（Log-Structured Merge-Tree）：

​	Lucene采用了类似的方法来保存其词典



B-trees：

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220315175340606.png" alt="image-20220315175340606" style="zoom:50%;margin-left:-2px" />





<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220328104825653.png" alt="image-20220328104825653" style="zoom:50%;margin-left:-2px" />



有针对事务处理的（OLTP）以及针对分析型的（OLAP）优化架构



REST是公共API的主流风格，RPC框架主要侧重于同一组织内多项服务之间的请求，通常发生在同一数据中心内



### 分布式数据系统

将数据分布在多节点时有两种常见的方式：复制、分区



##### 数据复制

三种流行的复制数据变化的方法：主从复制、多主节点复制和无主节点复制

主从复制：

​	只有主副本才可以接受写请求；从客户端角度来看，从副本都是只读的。

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220329163105362.png" alt="image-20220329163105362" style="zoom:50%;margin-left:-1px" />



同步复制与异步复制：

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220329163330634.png" alt="image-20220329163330634" style="zoom:50%;margin-left:-1px" />

链式复制是同步复制的一种变体





##### 处理节点失效

主节点失效：节点切换

在某些故障情况下，可能会发生两个节点同时都认为是主节点，这种情况被称为脑裂。



复制日志的实现

Mysql5.1版本之前采用基于操作语句的复制，如果语句存在不确定性的操作，则Mysql会切换到基于行的复制

基于行的逻辑日志复制

如果一条事务涉及多行的修改，则会产生多个这样的日志记录，并在后面跟着一条记录，指出该事务已经提交。Mysql的二进制日志binlog（当配置为基于行的复制时）使用该方式





基于主从复制如何实现写后读一致性？

* 如果用户访问可能会被修改的内容，从主节点读取，否则，在从节点读取
* 如果应用的大部分内容都可能被所有用户修改，那么上述方案方法将不太有效，它会导致大部分内容都必须经由主节点，这就丧失了读操作的扩展性。此时需要其他方案来判断是否从主节点读取
* 客户端还可以记住最近更新的时间戳
* 如果副本分布在多数据中心，情况会更复杂些



前缀一致读：对于一系列按照某个顺序发生的写请求，那么读取这些内容时也会按照当时写入的顺序



##### 多主节点复制

适应场景：多数据中心



主从复制就不太适合多数据中心的情景，写数据需要通过广域网（又称外网、公网）进行数据间的通信

有些数据库已内嵌支持多主复制，但有些借助外部工具来实现，例如Mysql的Tungsten Replicator，PGSql的BDR

缺点：多中心的写入会冲突

处理写冲突：

​	收敛于一致状态：

​		可能的方案：

​			1.给每个写入分配唯一的ID，例如一个时间戳，一个足够长的随机数...  挑选最高的ID作为胜利者，并将其他写入丢弃。【容易导致数据丢失】



##### 无主节点复制

客户端将写请求发送到多个节点上，读取时从多个节点并行读取，以此检测和纠正某些过期数据

​			

​			





### 数据分区

MongoDB、ElasticSearch和SolrCloud的shard，HBase的region

每个分区都可以视为一个完整的小型数据库

##### 键-值数据的分区

##### 基于关键字区间分区

​	

##### 基于关键字哈希值分区

​	采用哈希分区，通常事先创建好足够多（但固定数量）的分区，让每个节点承担多个分区。当添加或删除节点时将某些分区从一个节点迁移到另一个节点，也可以支持动态分区



### 分区再平衡

取模法 导致新增一个节点会重新分配对应资源的值





# 事务

有些人抱怨，常用的两阶段提交在性能和可用性方面代价太高，而我们认为事务滥用和过度使用所引入的性能瓶颈应该用应用层来解决，而不是简单的抛弃事务。

事务所提供的安全保证即大家所熟知的ACID，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）与持久性（Durability）

而不符合ACID标准的系统有时被冠以BASE，即基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventual consistency）

当然分布式系统有一个CAP的理论（Consistency、Availablility、Partition Tolerance）

* 原子性

  在出错时中止事务，并将部分完成的写入全部丢弃，也许可中止性比原子性更为准确

* 一致性

  对数据有特定的预期状态，任何数据更改必须满足这些状态约束（或者恒等条件）

  一致性更多是应用层的属性，应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不源于数据库。因此，字母C其实并不应该属于ACID（joe Hellerstein）

* 隔离性

* 持久性





##### 弱级别隔离

读-提交，它只能提供以下两个保证：

1.读数据库时，只能看到已成功提交的数据（防止脏读）

2.写数据库时，只会覆盖已成功提交的数据（防止脏写）

读-提交是pg，oracle11g 等数据库的默认配置

数据库通常采用行级锁来防止脏写

防止脏读 

​	使用相同的锁，所有试图读取该对象的事务必须先申请锁，事务完成后释放锁（这种不太适合，性能太差）

​	对于待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本。事务提交之前，所有其他读操作都读取旧值，仅当写事务提交之后，才会切换到读取新值

​	

不可重复读(norepetable read)或读倾斜（read skew）：暂时的不一致

有些场景不能容忍：

备份场景

分析查询与完整性检查场景



实现快照级别隔离

考虑到多个正在进行的事务可能会在不同的时间点查看数据库状态，所以数据库保留了对象多个不同的提交版本（MVCC）

支持快照级别隔离的存储引擎往往直接采用MVCC来实现读-提交隔离。典型的做法是，在读-提交级别下，对每一个不同的查询单独创建一个快照；而快照级别隔离则是使用一个快照来运行整个事务



并发写冲突是一个普遍问题，目前有多种可行的解决方案

* 原子写操作

* 显式加锁

  FOR UPDATE指令指示数据库对返回的所有结果行要加锁



写倾斜：即如果两个事务读取相同的一组对象，然后更新其中一部分，不同的事务可能更新不同的对象，则可能发现写倾斜

而不同事务如果更新的是同一个对象，则可能发生脏写或更新丢失

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220512160411485.png" alt="image-20220512160411485" style="zoom:50%;margin-left:-1px" />

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220512160509570.png" alt="image-20220512160509570" style="zoom:50%;margin-left:-1px" />



单线程执行有时可能会比支持并发的系统效率更高，尤其是避免锁开销。但是，其吞吐量上限是单个CPU核的吞吐量。



串行执行小结：

* 事务必须简短而高效
* 写入吞吐量必须足够低



##### 两阶段加锁（2PL）



##### 谓词锁

​	性能不佳

##### 索引区间锁





### 分布式系统所遇到的挑战



##### 不可靠时钟

墙上时钟

​	Java中System.currentTimeMillis() 会返回自纪元1970年1月1日（UTC）以来的秒数和毫秒数

单调时钟



节点不能根据自己的信息来判断自身的状态。由于节点可能随时失效，可能是暂停-假死，甚至是无法恢复。因此分布式系统不能完全依赖于单个节点。目前分布式系统都是靠法定票数。从而减少对特定节点的依赖



Fencing 令牌

当使用ZK作为锁服务的时，可以用事务标识zxid或节点版本cverision来充当fencing令牌，这两个都可以满足单调递增的要求。fencing令牌可以检测并阻止那些无意的误操作，但是不能避免那种伪造令牌的情况



拜占庭故障

节点明明没有收到某条消息，但却对外声称收到了。在这样不信任的环境中需要达成共识的问题也被称为拜占庭将军问题





### 一致性与共识

分布式系统最重要的抽象之一就是共识



### 全序关系广播

它要满足两个基本安全属性：

* 可靠发送
* 严格有序





### 分布式事务与共识

##### 两阶段提交（也被称为阻塞式提交）

两阶段提交（2PC）算法这是解决原子提交最常见的方法

2PC在某些数据库内部使用，或者以XA事务形式（例如Java Transaction API）或SOAP Web服务WS-AtomicTransaction的形式提供给应用程序

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220606111633755.png" alt="image-20220606111633755" style="zoom:50%;margin-left:-1px" />

2PC引入单节点事务所没有的一个新组件：事务协调者（也称为事务管理器）



协调者发生崩溃

<img src="/Users/yangli/Library/Application Support/typora-user-images/image-20220606113318187.png" alt="image-20220606113318187" style="zoom:50%;margin-left:-1px" />



##### 三阶段提交（非阻塞式提交）

3PC假定一个有界的网路延迟和节点在规定时间内响应。考虑到目前大多数具有无限网络延迟和进程暂停的实际情况，它无法保证原子性。普遍还是使用的2PC



共识算法必须满足以下性质：

* 协商一致性
* 诚实性
* 合法性
* 可终止性



共识算法对网络问题特别敏感

zk和etcd主要针对少量、可完全载入内存的数据（虽然他们最终要写入磁盘以支持持久性）而设计，所以不要用过它们保存大量的数据。它们采取容错的全序广播算法在所有节点上复制这些数据从而实现高可靠



Unix设计哲学：

* 每个程序做好一件事。如果要做新的工作，则建立一个全新的程序，而不是通过增加新“特征”使旧程序变得更加复杂
* 期待每个程序的输出称为另一个尚未确定的程序的输入。不要将输出与无关信息混淆在一起。避免使用表格状或二进制输入格式。不要使用交互式输入
* 尽早尝试设计和构建软件，甚至是操作系统，最好在几周内完成。需要扔掉那些笨拙的部分时不要犹豫，并立即进行重建

Unix工具最大的局限在于它们只能在一台机器上运行
