* XA
    是X/Open提出的分布式事务处理规范。XA是数据库的分布式事务，强一致性。
* SAGA
​		理论：长事务分拆成多个子事务。子事务正向操作Ti，子事务反向补偿操作Ci  

TCC
本地消息表
    ebay提出
    需要将分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多是应用于支付场景，通过对账系统对事后问题的处理
    本地消息表基于base理论
事务消息（RocketMQ4.3之后）
    rocketmq：事务回查，最多15次
最大努力通知
AT事务（seata）


分布式事务应用场景：
1.消息消费失败处理？ —— 属于消息通知吧
2.订单生成前扣款
  目前的业务是先生成订单 => 再扣款


分布式事务适用范围：
跨数据库实例产生分布式事务



产生分布式事务：
* 跨网络远程调用完成事务协作，就会产生分布式事务
* 跨数据库实例完成事务协作，就会产生分布式事务


分布式事务处理场景:
* 基于XA的两阶段提交协议来完成 —— 当前微服务情况下用的不是很普遍
    步骤：分成prepare、commit两步进行操作
    缺点：异常场景不能百分百处理（prepare预提交后事务协调器宕机，造成不能回滚；commit操作后造成数据库死锁等）
    rocketmq官方说的缺点：多分支环境下资源锁定范围大，并发度低，随着下游分支的增加，系统性能越来越差
* 基于弱一致性的事务补偿
    对于任何一个webservice接口，都要写一个逆向的接口进行回滚，调逆向接口进行正向数据的回滚，正向接口和负向接口都要具备幂等性
* 基于BASE理论的事务最终一致性(当前很常用的处理方式)
    根据消息中间件来操作，消息中间件进行解耦，把下一步的操作放到消息中间件中
    消息中间件还有重试机制，如发生错误会进行相应的重试

    防止消息丢失：
        1.做好消息确认机制（pulisher，consumer【手动ack】）
        2.每一个发送的消息都在数据库做好记录，定期将失败的消息再次发送一遍
    关于订单失效的解决方案：之前一直使用的定时器扫描一定时间段的失效订单，但是更优化的方案是在订单创建的时候，进行延迟消息

    拿订单来做例子，订单保存和启动工作流 作为一个分布式事务，可以用XA进行处理，消息中间件异步启动工作流，如果出现错误则进行重试，重试多次失败，则人工进行干预处理


技术实现：

Apache Seata框架支持AT、TCC、SAGA和XA事务模式
写隔离：
    1.一阶段本地事务提交前，需要确保先拿到<strong>全局锁</strong>
    2.拿不到全局锁，不能提交本地事务
    3.拿<strong>全局锁</strong>的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁

读隔离：
    在数据库本地事务隔离级别<strong>读已提交</strong>或以上的基础上，Seata（AT模式）默认全局的隔离级别是<strong>读未提交</strong>
    如果应用在特定场景下，必须要求全局的读已提交，目前Seata的方式是通过SELECT FOR UPDATE语句的代理


根据两阶段行为模式的不同，我们将分支事务划分为Automatic（Branch）Transaction Mode和Manual（Branch）Transaction Mode
AT模式基于支持本地ACID事务的关系型数据库：
    1)一阶段prepare行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录
    2)二阶段commit行为：马上成功结束，自动异步批量清理回滚日志
    3)二阶段rollback行为：通过回滚日志，自动生成补偿操作，完成数据回滚


TCC模式，不依赖于底层数据资源的事务支持：
    1)一阶段prepare行为，调用自定义的prepare逻辑
    2)二阶段commit行为，调用自定义的commit逻辑
    3)二阶段rollback行为，调用自定义的rollback逻辑
所谓TCC模式，是指支持把自定义的分支事务纳入到全局事务的管理中
    适用范围：
    1)强隔离性、严格一致性要求的业务活动
    2)适用于执行时间比较短的业务

SAGA模式
    最终一致性解决方案
    SEATA提供的长事务解决方案，在SAGA模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现
    适用场景：
        1)业务流程长，业务流程多
        2)参与者包含其他公司或遗留系统服务，无法提供TCC模式要求的三个接口
    优势：
        1)一阶段提交本地事务，无锁，高性能
        2)事件驱动架构，参与者可异步执行，高吞吐
        3)补偿服务易于实现
    缺点：
        不保证隔离性

    SAGA实现：
    基于状态机引擎的Saga实现：
    目前seata提供的Saga模式是基于状态机引擎来实现的，机制是：
    1)通过状态图来定义服务调用的流程并生成json状态语言定义文件
    2)状态图中一个节点可以是调用一个服务，节点可以配置它的补偿节点
    3)状态图json由状态机引擎驱动执行，当出现异常时状态引擎反向执行已成功节点对应的补偿节点将事务回滚（注意：异常发生时是否进行补偿也可由用户自定义决定）
    4)可以实现服务编排需求，支持单项选择、并发、子流程、参数转换、参数映射、服务执行状态判断、异常捕获等功能



* XA
    AP（Application Program）：AP定义事务的边界（定义事务开始和结束）并访问事务边界内的资源
    RM（Resource Manager）：RM管理计算机共享的资源，资源包含比如数据库、文件系统、打印机服务等
    TM（Transaction Manager）：管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等

    Java的JTA来完成Mysql的分布式事务
    